//
// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#ifndef _SU_SUBCHUNKRENDERER_H_
#define _SU_SUBCHUNKRENDERER_H_

#include "SuFrustum.h"

class SuModelSubChunk;
class SuSubChunkState;
class SuCamera;
class SuSubChunkTree;
class SuSubChunkTreeNode;

//=================================================================================================================================
/// \ingroup ObjectManager
/// \brief A class which is responsible for determining which subchunks of a chunk to render, and in what order
/// 
///   Sub-chunks are used to break a very large model into small pieces which can be drawn with the same rendering state.  
///   Performing frustum-culling at the sub-chunk level can help to reduce geometry load.  The job of the subchunk renderer is to
///   perform this frustum culling, and to determine the draw calls that must be issued to render the visible portions of the object.
///
///   Whenever possible, the renderer will combine multiple sub-chunks into a single draw call.
///   
///   In order to support multiple object instances with different animation, the subchunk renderer is divided into two classes,
///   a renderer class, which performs the necessary culling, and a state class, which holds the bounding volumes of the
///   subchunks for each instance of the object.
///
///   The SuSubchunkState class is, by design, tightly coupled with the SuSubChunkRenderer class
///
//=================================================================================================================================
class SuSubChunkRenderer
{
public:

   /// Information about a draw call that needs to be issued to render a particular subchunk
   struct DrawCall
   {
      uint32 nFirstIndex;
      uint32 nIndexCount;
      uint32 nFirstVertex;
      uint32 nLastVertex;
   };

   /// Constructor.  Creates an empty renderer.
   SuSubChunkRenderer( );

   /// Destructor
   ~SuSubChunkRenderer();

   /// Initializes the subchunk renderer with a set of subchunks
   void Initialize(  const SuArray<SuModelSubChunk>& rSubchunks, const SuArray<SuSubChunkTree*>& rTrees );

   /// Creates a state object for the subchunk renderer, which holds information about the subchunk bounding volumes
   SuSubChunkState* CreateState( ) const;

   /// Updates the subchunk rendering order, based on the subchunk state and camera
   void UpdateRenderingOrder( const SuSubChunkState* pState, const SuCamera* pCamera ) ;

   /// Returns the number of draw calls in the rendering order
   uint32 GetNumDrawCalls() const;

   /// Accessor for the draw calls needed in the rendering order
   const DrawCall* GetDrawCalls() const;

   /// Issues the draw calls created by a previous call to UpdateRenderingOrder
   void DrawIndexed( SuRenderManager::PrimType ePrimType, uint8 nIndexSize, uint32 nInstances = 1) const;

   /// Issues the draw calls created by a previous call to UpdateRenderingOrder using DrawNonIndexed
   void DrawNonIndexed( SuRenderManager::PrimType ePrimType, uint32 nInstances = 1) const;


private:

   /// Updates the rendering order by using one frustum test per subchunk
   void UpdateRenderingOrderFlat( const SuSubChunkState* pState, const SuCamera* pCamera );

   /// Updates the rendering order by using subchunk trees
   void UpdateRenderingOrderTree(  const SuSubChunkState* pState, const SuCamera* pCamera );

   SuArray<DrawCall> m_currentDrawCalls;   ///< Set of draw calls generated by last update
   uint32 m_nNumCurrentDrawCalls;          ///< Number of draw calls in m_currentDrawCalls which should be taken seriously

   SuArray<SuModelSubChunk> m_SubChunks;   ///< Array of subchunks used by this renderer
   SuArray<DrawCall> m_subchunkDrawCalls;  ///< Set of draw calls for each individual subchunk, used to build m_currentDrawCalls.  When possible, adjacent subchunks are combined

   SuArray<SuSubChunkTree*> m_trees;            ///< Subchunk trees (optional)
   SuArray<const SuSubChunkTreeNode*> m_stack;  ///< Stack used for traversing subchunk trees

   SuArray<SuFrustum> m_frusta;           ///< Array of frusta used for object-space culling
};


#endif // _SU_SUBCHUNKRENDERER_H_
