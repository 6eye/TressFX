//=================================================================================================================================
//
// Author: Jeremy Shopf
//         Game Computing Applications Group
//         AMD Graphics Products Group
//
// Full-screen quad shader for raycasting binned metaballs
//=================================================================================================================================
// $Id: //depot/3darg/Demos/Effects/TressFXRelease/amd_tressfx_sample/bin/Effects/D3D11/qSSAO.sufx#1 $ 
// 
// Last check-in:  $DateTime: 2017/03/28 18:02:41 $ 
// Last edited by: $Author: khillesl $
//=================================================================================================================================
//   (C) AMD, Inc. 2008 All rights reserved. 
//=================================================================================================================================


// ART NOTES ======================================================================================================================
ArtNotes()
{
   A shader for shading particle splats
}


// MISC ===========================================================================================================================
Options <  >

// INCLUDES =======================================================================================================================
#include "SuMath.shl"

// STREAMS  =======================================================================================================================
Stream QuadStream < Normal >
{
   float3 POSITION  Position,
   float2 TEXCOORD0 UV < slot = "color" >

};

StreamMap sm1 { QuadStream }

// MISC ===========================================================================================================================

// TEXTURES =======================================================================================================================
Texture2D tRandom < BindRT = "./Objects/SSAOTextures.suo2::material.tRandom" >

//Texture2D tRandom < format = RGBA, colorSpace = Linear, 
//                      source0 = < fileName = "S:/Demos/CommonImages/randomfloat4_256.dds", channels = RGBA, colorSpace = Linear > >

//Texture2D tDepth   < BindRT = "tDepthSS" >
Texture2D tDepth   < BindRT = "zNormals" >
Texture2D tNormals < BindRT = "tNormals" >
Texture2D tAO      < BindRT = "ScriptVariable", Name = "tAOIn" >

//Texture2D tShadingBuffer < BindRT = "ScriptVariable", Name = "SSAO_BlurIn" >

Sampler sPoint
{
   Texture = tDepth;
   Filter  = MIN_MAG_MIP_POINT;
   AddressU = CLAMP;
   AddressV = CLAMP;
};

Sampler sPointWrap
{
   Texture = tDepth;
   Filter  = MIN_MAG_MIP_POINT;
   AddressU = WRAP;
   AddressV = WRAP;
};

Sampler sLinear
{
   Texture = tDepth;
   Filter  = MIN_MAG_LINEAR_MIP_POINT;
   AddressU = CLAMP;
   AddressV = CLAMP;
};

// PARAMETERS =====================================================================================================================
Matrix mV                  < AppUpdate = ViewMatrix >
Matrix mP                  < AppUpdate = ProjMatrix >
Matrix mVP                 < AppUpdate = ViewProjMatrix > 
Matrix mInvV               < AppUpdate = ViewMatrixInverse >
Matrix mInvP               < AppUpdate = ProjMatrixInverse >
Matrix mInvVP              < AppUpdate = ViewProjMatrixInverse >
Vector vCameraProjParams   < AppUpdate = CameraProjParams >
Vector vCameraPosition     < AppUpdate = CameraPosition >
Vector vViewport           < AppUpdate = Viewport >
Vector vCameraPosWS        < AppUpdate = CameraPosition >
Bool   bBlur               < AppUpdate = "ScriptVariable", Name = "bBlur" >

Float  fSampleSize         < AppUpdate = "ScriptVariable", Name = "fSampleSize" >
Float  fAngleFalloff       < AppUpdate = "ScriptVariable", Name = "SSAO.fAngleFalloff" >
Float  fSampleRadius(5.0)  < AppUpdate = "ScriptVariable", Name = "SSAO.fSampleRadius" >
Float  fBlurRadius(3.0)    < AppUpdate = "ScriptVariable", Name = "SSAO.fBlurRadius" >
Float  fSharpness          < AppUpdate = "ScriptVariable", Name = "SSAO.fSharpness" >
Float  fOcclusionScale(1.0)< AppUpdate = "ScriptVariable", Name = "SSAO.fOcclusionScale" >
Float  fEpsilon(.0001)     < AppUpdate = "ScriptVariable", Name = "SSAO.fEpsilon" >
Float  fDistFalloff(3.0)   < AppUpdate = "ScriptVariable", Name = "SSAO.fDistFalloff" >
Float  fDepthFalloff(3.0)  < AppUpdate = "ScriptVariable", Name = "SSAO.fDepthFalloff" >
Float  fViewWidth          < AppUpdate = "ScriptVariable", Name = "fViewWidth" >
Vector ssaoSamplePositions[32]     < AppUpdate = "ScriptVariable", Name = "ssaoSamplePositions">


// HBAO PARAMETERS  ===============================================================================================================
Float g_fR              < AppUpdate = "ScriptVariable", Name = "HBAO.g_fR" >
Float g_fSqrR           < AppUpdate = "ScriptVariable", Name = "HBAO.g_fSqrR" >
Float g_fInvR           < AppUpdate = "ScriptVariable", Name = "HBAO.g_fInvR" >
Float g_fAttenuation    < AppUpdate = "ScriptVariable", Name = "HBAO.g_fAttenuation" >
Float g_fNumDir         < AppUpdate = "ScriptVariable", Name = "HBAO.g_fNumDir" >
Float g_fNumSteps       < AppUpdate = "ScriptVariable", Name = "HBAO.g_fNumSteps" >
Float g_fContrast       < AppUpdate = "ScriptVariable", Name = "HBAO.g_fContrast" >
Float g_fAngleBias      < AppUpdate = "ScriptVariable", Name = "HBAO.g_fAngleBias" >
Float g_fTanAngleBias   < AppUpdate = "ScriptVariable", Name = "HBAO.g_fTanAngleBias" >
Vector g_vFocalLen       < AppUpdate = "ScriptVariable", Name = "HBAO.g_vFocalLen" >



// HLSL ===========================================================================================================================
StartHLSL "Transforms"

   float3 GetWorldSpaceFromUV( float2 vUV, float fZ )
   {
      float4 vPosCS = float4( 0, 0, fZ, 1 );

                     // 0-2,-2-0         //-1 to 1, 1 to -1
      vPosCS.xy = vUV*float2(2.0,-2.0) + float2(-1.0,1.0);      // transform position into clip-space
      float4 vPosWS = mul( mInvVP, vPosCS );
      vPosWS.xyz /= vPosWS.w;
      return vPosWS.xyz;
   }

   float3 GetViewSpaceFromUV( float2 vUV, float fZ )
   {
      float4 vPosCS = float4( 0, 0, fZ, 1 );
                     // 0-2,-2-0         //-1 to 1, 1 to -1
      vPosCS.xy = vUV*float2(2.0,-2.0) + float2(-1.0,1.0);      // transform position into clip-space
      float4 vPosVS = mul( mInvP, vPosCS );
      vPosVS.xyz /= vPosVS.w;
      return vPosVS.xyz;
   }
   
   float4 GetViewSpace4FromUV( float2 vUV, float fZ)
   {
      float4 vPosCS = float4( 0, 0, fZ, 1 );
                     // 0-2,-2-0         //-1 to 1, 1 to -1
      vPosCS.xy = vUV*float2(2.0,-2.0) + float2(-1.0,1.0);      // transform position into clip-space
      float4 vPosVS = mul( mInvP, vPosCS );
      vPosVS.xyz /= vPosVS.w;
      return vPosVS.xyzw;
   }

   float3 GetWorldSpaceFromSS( float2 vPosSS, float fZ )
   {
      float4 vPosCS = float4( 0, 0, fZ, 1 );
      float2 vUV = vPosSS/vViewport.zw;

      return GetWorldSpaceFromUV( vUV, fZ );
   }


   float3 GetViewSpaceFromSS( float2 vPosSS, float fZ )
   {
      float4 vPosCS = float4( 0, 0, fZ, 1 );
      float2 vUV = vPosSS/vViewport.zw;

      return GetViewSpaceFromUV( vUV, fZ );
   }



EndHLSL

StartHLSL "Bilateral"

   float ApplyFilter( float2 vUV, int nOffset, int nCoordIndex, float fValue, float fLinearDepth, inout float fCumulativeWeight )
   {
      int2 n2DOffset = 0;
      n2DOffset[nCoordIndex] = nOffset;

      float4 vSample = tAO.SampleLevel( sPoint, vUV + n2DOffset/vViewport.zw, n2DOffset, 0 );
      float fSampleAO = vSample.x;
      float fSampleDepth = tDepth.SampleLevel( sPoint, vUV + n2DOffset/vViewport.zw, n2DOffset, 0 );

      float fLinearSampleDepth = -GetViewSpaceFromUV( vUV + n2DOffset/vViewport.zw, fSampleDepth ).z;
      //fLinearSampleDepth /= -(vCameraProjParams.w - vCameraProjParams.z); //0..1


      float fDepthDiff = fLinearSampleDepth - fLinearDepth;
      float fFalloff = .00000004;
      float fSharpness = 1000;

      //float fWeight = saturate(exp( -(nOffset*nOffset*fFalloff + fDepthDiff*fDepthDiff*fSharpness) )*vSample.a );
      float fWeight = saturate( exp( -(nOffset*nOffset*fFalloff + fDepthDiff*fDepthDiff*fSharpness ) ));

      //*step(0.0,vSample.a)
      //float fWeight = saturate(exp(-(fDepthDiff*fDepthDiff*fSharpness)));
      //float fWeight = saturate( exp( -nOffset*nOffset*fFalloff ) );

      fCumulativeWeight += fWeight;

      return fSampleAO*fWeight;
   }


EndHLSL

StartHLSL "SSAOCommon"
   float2 rotate_direction(float2 Dir, float2 CosSin)
   {
       return float2(Dir.x*CosSin.x - Dir.y*CosSin.y, 
                     Dir.x*CosSin.y + Dir.y*CosSin.x);
   }

   float2 SelectSampleUVRotated( float2 vUV, int nSample, float fRadius, float fAlpha, float3 vRand )
   {
      float3 vOffset[32] = {
         float3( 0.1, 0.0, 1.0 ),
         //float3( 0.980084, 0.007705,  -0.198433 ),
         float3( 0.197163, 0.529858,  -0.824850 ),
         float3( -0.858993, -0.508074, 0.063189 ),
         float3( -0.189187, 0.259394, -0.947060 ),
         float3( 0.315754, -0.641066, -0.699524 ),
         float3( 0.196800, 0.380950,  -0.903409 ),
         float3( -0.245416, -0.968485, -0.042508 ),
         float3( -0.015660, 0.044376, 0.998892 ),
         float3( 0.764593, 0.494733,  0.413083 ),
         float3( 0.299423, 0.397818,  0.867229 ),
         float3( 0.982921, -0.070992, 0.169786 ),
         float3( 0.010751, 0.009980,  0.999892 ),
         float3( 0.925851, 0.051894,  0.374309 ),
         float3( -0.955866, -0.192712,-0.221773 ),
         float3( -0.757403, -0.563215,-0.330347 ),
         float3( 0.437878, 0.753691,  -0.490114 ),
         float3( -0.851617, 0.272048, 0.448039 ),
         float3( 0.883385, 0.330883,  -0.331885 ),
         float3( 0.120773, -0.568454, -0.813802 ),
         float3( -0.806270, -0.101252, 0.582818 ),
         float3( 0.538524, -0.531982, -0.653443 ),
         float3( 0.222431, -0.063260, -0.972894 ),
         float3( -0.419263, -0.105835, 0.901675 ),
         float3( -0.654742, 0.159015, 0.738937 ),
         float3( 0.396645, -0.465955, 0.790923 ),
         float3( 0.087380, -0.463499, -0.881778 ),
         float3( 0.000959, -0.000019, -1.000000 ),
         float3( -0.721241, -0.608197, 0.331523 ),
         float3( -0.081757, 0.799798, 0.594675 ),
         float3( 0.039988, -0.062886, 0.997219 ),
         float3( -0.203967, 0.201760, 0.957962 ),
         float3( -0.077584, -0.157630, 0.984446 ) };

      float fAngle = fAlpha * nSample;
      float2 vDir = float2(cos(fAngle), sin(fAngle));
      float2 vDeltaUV = rotate_direction(vDir, vRand.xy) * fRadius * fSampleRadius * 150 * vOffset[nSample].z;
      //float2 vDeltaUV = vDir * fRadius * fSampleRadius * 100 * vOffset[nSample].z;

      return vUV + vDeltaUV;
   }
    
    float4 ssaoSamplePositions[32];
    float3 SelectSampleKernel(int i)
    {
        return ssaoSamplePositions[i].rgb;
    }

   float2 SelectSampleUV( float3 vPosVS, int nSample)
   {
      // Offsets for texture lookups
      float3 vOffset[32] = {
         //float3( 0, 0.0, 1.0 ),
         float3( 0.980084, 0.007705,  0.198433 ),
         float3( 0.197163, 0.529858,  0.824850 ),
         float3( -0.858993, -0.508074, 0.063189 ),
         float3( -0.189187, 0.259394, 0.947060 ),
         float3( 0.315754, -0.641066, 0.699524 ),
         float3( 0.196800, 0.380950,  0.903409 ),
         float3( -0.245416, -0.968485, 0.042508 ),
         float3( -0.015660, 0.044376, 0.998892 ),
         float3( 0.764593, 0.494733,  0.413083 ),
         float3( 0.299423, 0.397818,  0.867229 ),
         float3( 0.982921, -0.070992, 0.169786 ),
         float3( 0.010751, 0.009980,  0.999892 ),
         float3( 0.925851, 0.051894,  0.374309 ),
         float3( -0.955866, -0.192712,0.221773 ),
         float3( -0.757403, -0.563215,0.330347 ),
         float3( 0.437878, 0.753691,  0.490114 ),
         float3( -0.851617, 0.272048, 0.448039 ),
         float3( 0.883385, 0.330883,  0.331885 ),
         float3( 0.120773, -0.568454, 0.813802 ),
         float3( -0.806270, -0.101252, 0.582818 ),
         float3( 0.538524, -0.531982, 0.653443 ),
         float3( 0.222431, -0.063260, 0.972894 ),
         float3( -0.419263, -0.105835, 0.901675 ),
         float3( -0.654742, 0.159015, 0.738937 ),
         float3( 0.396645, -0.465955, 0.790923 ),
         float3( 0.087380, -0.463499, 0.881778 ),
         float3( 0.000959, -0.000019, 1.000000 ),
         float3( -0.721241, -0.608197, 0.331523 ),
         float3( -0.081757, 0.799798, 0.594675 ),
         float3( 0.039988, -0.062886, 0.997219 ),
         float3( -0.203967, 0.201760, 0.957962 ),
         float3( -0.077584, -0.157630, 0.984446 ) };
         
         float3 vRay = normalize( vOffset[nSample].xyz ) * fSampleRadius * 2;
         float3 vSamplePosVS = vPosVS + vRay;

         // Get "neighbor" position in screen-space
         float4 vSamplePosSS = mul( mP, float4(vSamplePosVS,1) );

         // Convert neighbor position to a UV  (is this flipped)?
         float2 vSampleTexCoord = 0.5f * (vSamplePosSS.xy/vSamplePosSS.w) + float2(0.5f, 0.5f);
         vSampleTexCoord.y = 1.0 - vSampleTexCoord.y;

         return vSampleTexCoord;
   }

   // Nearby stuff occludes more
   float DistanceFactor( float3 vDistVS )
   {
         float fDistVS = length(vDistVS);
         float fDistFactor = pow( saturate(fDistVS/fDistFalloff), 1 );
         fDistFactor = 1.0 - fDistFactor;

         return fDistFactor;
   }

   // Nearby stuff occludes more
   float DepthFactor( float fLinearDepth, float fLinearSampleDepth )
   {
      // Ignore samples that are behind our shaded pixel
      float fDepthDiff = fLinearDepth-fLinearSampleDepth; // positive values indicate our shaded point is further back

      // If this surface shouldn't be occluded
      fDepthDiff = fDepthDiff < 0.6 ? 0.0 : fDepthDiff;             // If the sample is not occluding
      fDepthDiff = fDepthDiff >= fDepthFalloff  ? 0.0 : fDepthDiff;  // If the sample is too far
      return 1.0 - fDepthDiff / fDepthFalloff;
   }

EndHLSL

Technique SSAO
{
    Pass P0
    {
        RenderTargetFormat = SU_FORMAT_R8_UNORM
        StreamMap = sm1
        CullMode = NONE
        
        ZEnable = false;
        ZWriteEnable = false;
        BlendEnable = false;
        SrcBlend = ZERO;
        DstBlend = SRCALPHA;
        BlendOp = ADD;
        
        VertexShader(HLSL, EntryPoint="VS")
        
            struct VsInput
            {
                float3 vPosition :Position;
            };
            
            struct VsOutput
            {
                float4 vPosition : SV_POSITION;
            };
            
            VsOutput VS(VsInput i)
            {
                VsOutput o;
                
                o.vPosition = float4(i.vPosition, 1);
                
                return o;
            }
            
        EndVertexShader
        
        PixelShader(HLSL, EntryPoint="PS")
            
            struct PsInput
            {
                float4 vPosition   : SV_POSITION;
            };
            
            Texture2D<float4> tRandom;
            Texture2D<float> tDepth;
            Texture2D<float4> tNormals;
            
            SamplerState sPoint;
            SamplerState sLinear;
            
            // A lot of these aren't used directly in the shader
            // but they have to be here because they are in the includes.
            float4x4 mInvVP;
            float4x4 mInvP;
            float4x4 mV;
            float4x4 mP;
            float4   vCameraPosition;
            
            float4   vCameraProjParams;
            float4   vViewport;
            float    fSampleRadius;
            float    fDistFalloff;
            float    fAngleFalloff;
            float    fDepthFalloff;
            float    fViewWidth;
            float    fSampleSize;
            
            $include "Transforms"
            $include "Math"
            $include "SSAOCommon"
            
            float4 PS(PsInput i) : SV_TARGET
            {
                
                float2 vUV = i.vPosition.xy/vViewport.zw;
                float depth = tDepth.Sample(sLinear, vUV).r;
                
                float zFar = vCameraProjParams.w;
                float zNear = vCameraProjParams.z;
                
                float3 origin = GetViewSpaceFromUV(vUV, depth);
                float3 normal = tNormals[i.vPosition.xy].xyz * 2.0 - 1.0;
                normal = mul(mV, normal);
                normal = normalize(normal);
                
                float3 rvec = normalize(float3(tRandom.Load(int3((int)i.vPosition.x&127, (int)i.vPosition.y&127, 0)).xy, 0.0)) * 2.0 - 1.0;
                float3 tangent = normalize(rvec - (normal * dot(rvec, normal)));
                float3 bitangent = cross(normal, tangent);
                float3x3 tbn = float3x3(tangent, bitangent, normal);
                
                float occlusion = 0.0;
                [loop]
                for(int i =0; i < fSampleSize; i++)
                {
                    float3 kernel = SelectSampleKernel(i);
                    float3 samplePosition = mul(kernel, tbn);
                    
                    samplePosition = samplePosition * fSampleRadius + origin;
                    
                    float4 offset = float4(samplePosition, 1.0);
                    offset = mul(mP, offset);
                    offset.xy /= offset.w;
                    offset.xy = offset.xy * float2(0.5,-0.5) + 0.5;
                    
                    float sampleDepth = tDepth.Sample(sLinear,offset.xy).r;
                    
                    float sampleDepthVS = GetViewSpaceFromUV(offset.xy, sampleDepth).z;
                    
                    float rangeCheck = abs(origin.z - sampleDepthVS) < fSampleRadius ? 1.0 : 0.0;
                    
                    if(rangeCheck == 1.0)
                    {
                        occlusion += (sampleDepthVS <= samplePosition.z ? 1.0 : 0.0);
                    }
                    else
                    {
                        occlusion += 1;
                    }
            
                }
                occlusion = (occlusion / fSampleSize);
                
                
                return occlusion;
            }
        EndPixelShader
    }
}

StartHLSL "GaussianCommons"

    float GetOffsetAtIndex(int index)
    {
        float offset[15] =
        {
            0.0,1.0,2.0,3.0,4.0,5.0,
            6.0,7.0,8.0,9.0,10.0,11.0,
            12.0,13.0,14.0
        };
        
        return offset[index];
    }
    
    float GetWeightAtIndex(int index)
    {
        // Weights are a pre calculated bassed off the Gaussian Function.
        //float weights[11] =
        //{
        //    0.133039006,0.125849508,0.106529308,
        //    0.080692236,0.054693971,0.03317357,
        //    0.018004872,0.008744458,0.003800326,
        //    0.00147793,0.000514318
        //};
        
        float weights[15] =
        {
            0.099763364,0.096693968,0.08804086,
            0.075305338,0.060509539,0.045674996,
            0.032388422,0.021575341,0.013501503,
            0.007937124,0.004383296,0.002274024,
            0.001108271,0.000507403,0.000218231
        };
        
        return weights[index];
    }

EndHLSL

Technique GaussianBlurX
{
    Pass P0
    {
        RenderTargetFormat = SU_FORMAT_R8_UNORM
        StreamMap = sm1
        CullMode = NONE
        
        ZEnable = false;
        ZWriteEnable = false;
        BlendEnable = false;
        SrcBlend = ZERO;
        DstBlend = SRCALPHA;
        BlendOp = ADD;
        
        VertexShader(HLSL, EntryPoint="VS")
        
            struct VsInput
            {
                float3 vPosition :Position;
            };
            
            struct VsOutput
            {
                float4 vPosition : SV_POSITION;
            };
            
            VsOutput VS(VsInput i)
            {
                VsOutput o;
                
                o.vPosition = float4(i.vPosition, 1);
                
                return o;
            }
            
        EndVertexShader
        
        PixelShader(HLSL, EntryPoint="PS")
        
            $include "GaussianCommons"
        
            SamplerState sLinear;
            Texture2D<float> tAO;
            
            float4   vViewport;
            
            struct PsInput
            {
                float4 vPosition : SV_POSITION;
            };
            
            float4 PS(PsInput i) : SV_TARGET
            {
                float2 UV = i.vPosition.xy;
                float color = tAO[UV] * GetWeightAtIndex(0);
                
                for(int i = 1; i < 15; i++)
                {
                    float offset = GetOffsetAtIndex(i);
                    float weight = GetWeightAtIndex(i);
                    
                    color += tAO[UV + float2(offset,0.0)] * weight;
                    color += tAO[UV - float2(offset,0.0)] * weight;
                }
                
                return color;
            }
            
        EndPixelShader
    }
}

Technique GaussianBlurY
{
    Pass P0
    {
        RenderTargetFormat = SU_FORMAT_R8_UNORM
        StreamMap = sm1
        CullMode = NONE
        
        ZEnable = false;
        ZWriteEnable = false;
        BlendEnable = false;
        SrcBlend = ZERO;
        DstBlend = SRCALPHA;
        BlendOp = ADD;
        
        VertexShader(HLSL, EntryPoint="VS")
        
            struct VsInput
            {
                float3 vPosition :Position;
            };
            
            struct VsOutput
            {
                float4 vPosition : SV_POSITION;
            };
            
            VsOutput VS(VsInput i)
            {
                VsOutput o;
                
                o.vPosition = float4(i.vPosition, 1);
                
                return o;
            }
            
        EndVertexShader
        
        PixelShader(HLSL, EntryPoint="PS")
        
            $include "GaussianCommons"
            
            SamplerState sLinear;
            Texture2D<float> tAO;
            
            float4   vViewport;
            
            struct PsInput
            {
                float4 vPosition : SV_POSITION;
            };
            
            float4 PS(PsInput i) : SV_TARGET
            {
               float2 UV = i.vPosition.xy;
                float color = tAO[UV] * GetWeightAtIndex(0);
                
                for(int i = 1; i < 15; i++)
                {
                    float offset = GetOffsetAtIndex(i);
                    float weight = GetWeightAtIndex(i);
                    
                    color += tAO[UV + float2(0.0,offset)] * weight;
                    color += tAO[UV - float2(0.0,offset)] * weight;
                }
                
                return color;
            }
            
        EndPixelShader
    }
}

Technique OldSSAO
{
   Pass P0
   {
      StreamMap = sm1
      CullMode = NONE

      // DEPTH STATE
      ZEnable = false
      ZWriteEnable = false
      BlendEnable = false;
      SrcBlend = ZERO;
      DstBlend = SRCALPHA;
      BlendOp = ADD;

      VertexShader(HLSL, EntryPoint="VS")
      struct VsInput
      {
        float3 vPosition : Position;
      };

      struct VsOutput
      {
         float4 vPosition   : SV_POSITION;
      };

      $include "Math"
      float4   vCameraProjParams;

      VsOutput VS( VsInput i )
      {
         VsOutput o;

         // We are rendering a full-screen quad here
         o.vPosition = float4( i.vPosition.xy, 0, 1 );

         // TODO: pass this in as a uniform
         // Calculate the view-space position on the far plane
         float3 vFarCornerVS = 0;
         float fFOV_radians = vCameraProjParams.x/180.0*SU_PI;
         float fFar = vCameraProjParams.w;
         float fAspect = vCameraProjParams.y;

         return o;
      }
      EndVertexShader

      PixelShader(HLSL, EntryPoint="PS")

         struct PsInput
         {
           float4 vPosition   : SV_POSITION;
         };

         Texture2D<float4> tRandom;
         Texture2D<float>  tDepth;
         Texture2D<float4> tNormals;
         SamplerState sLinear;
         SamplerState sPoint;

         float4x4 mInvVP;
         float4x4 mInvP;
         float4x4 mV;
         float4x4 mP;

         float4   vCameraProjParams;
         float4   vViewport;
         float fSampleRadius;
         float    fEpsilon;
         float    fDistFalloff;
         float    fAngleFalloff;
         float    fOcclusionScale;
         float    fDepthFalloff;
         float    fViewWidth;

         $include "Transforms"
         $include "Math"
         $include "SSAOCommon"

         float4 PS( PsInput i ) : SV_TARGET
         {
            float    fTempSampleRadius = 1;
            
            float2 vUV = i.vPosition.xy/vViewport.zw;

            // Get the depth for the point being shaded
	         float fDepth = tDepth.SampleLevel( sPoint, vUV, 0 );

            // Get worldspace normal
            float3 vNormalVS = normalize(tNormals.SampleLevel( sLinear, vUV, 0 ).xyz*2.0-1.0);

            // Assuming these are both in view-space, find the view space position of the pixel
	         float3 vPositionVS = GetViewSpaceFromSS( i.vPosition.xy, fDepth );
            
            float fLinearDepth = -vPositionVS.z;
         	
            float3 vViewVS = normalize( vPositionVS.xyz );

            // Grab a random 3 vector to use for rotating samples
            float3 vRandNormal = normalize( tRandom.SampleLevel( sLinear, vUV, 0 )*2.0-1.0 );

	         float vFinalColor = 0.0;
            float fLinearSampleDepth = 0;
            float fValidSamples = 0;
      	   static const int nSamples = 16;

            float fAlpha = 2.0f * SU_PI / nSamples;

            float3 vRand = tRandom.Load(int3((int)i.vPosition.x&127, (int)i.vPosition.y&127, 0)).xyz*.8;

            float fHalfPixelWidth = (fViewWidth/vViewport.z)*.5;
            float fNear = vCameraProjParams.z;
            float fRadius = (fSampleRadius*fNear)/(fLinearDepth+fNear);

            [loop]
	         for( int j=0; j<nSamples; j++ )
	         {

               // Use 3D offset
               float2 vSampleTexCoord = SelectSampleUV( vPositionVS, j);
               // Use 2D offset
               //float2 vSampleTexCoord = SelectSampleUVRotated( vUV, j, fRadius, fAlpha, vRand.xyz );

               // Get neighbor's depth from the sampling coord
		         float fSampleDepth = tDepth.SampleLevel( sPoint, vSampleTexCoord, 0 );

               // Transform to view-space
      		   float3 vNeighborPosVS = GetViewSpaceFromUV( vSampleTexCoord, fSampleDepth );
               float3 vSampleNormalVS = tNormals.SampleLevel( sPoint, vSampleTexCoord, 0 ).xyz*2.0-1.0;

               vNeighborPosVS -= vSampleNormalVS*.03;

               // Get linear depth
               fLinearSampleDepth = -vNeighborPosVS.z;

               float3 vDistVS = vPositionVS - vNeighborPosVS;

               float fSphereRadius = max( 0, ((fNear + fLinearSampleDepth)*fHalfPixelWidth)/fNear );

               //if( length( vDistVS ) < fSphereRadius )
               //   return float4(1,1,0,1);

               //float fOcclusion = asin( saturate(fSphereRadius/length( vDistVS )) );
               //float fOcclusion = fSphereRadius/length( vDistVS );
               //float fOcclusion = saturate(fSphereRadius/length( vDistVS ));//length( vDistVS ).xxx;
               float fOcclusion = cos( asin( fSphereRadius/(length( vDistVS )+fSphereRadius) ) );
               
               if( fOcclusion < 0 || fOcclusion > 1 )
                  return float4(1,0,0,1);

               //fFinalColor += dot( normalize(vSampleNormalVS), normalize(vNormalVS) ) > 0.99 ? 0.0 : 1.0;

               float fAngleThreshold = saturate(dot( vSampleNormalVS, vNormalVS ));
               //float fNormalSimilarity = saturate( dot( vSampleNormalWS, vNormalWS ) );
               //fAngleThreshold = sign( max( 0.0, fAngleThreshold - .3 ) );

               //vFinalColor += fAngleThreshold;
               //vFinalColor += (vDistVS)*100;//*.5+.5;
               //vFinalColor += vSampleNormalVS;
               //vFinalColor += fAngleThreshold;
               vFinalColor += fOcclusion * saturate(dot( normalize( vDistVS ), vNormalVS ) ) * fAngleThreshold;//*(1-dot( normalize(vSampleNormalVS), normalize( vDistVS ) ));

               //float fDistFactor = DistanceFactor( vDistVS );
               //float fDepthFactor = DepthFactor( fLinearDepth, fLinearSampleDepth );

               //float fAngleThreshold = dot( normalize(vSampleNormalWS), normalize(vPositionWS - vNeighborPosWS)/*/(length(vPositionVS - vNeighborPosVS)+.01)*/ );
               //fAngleThreshold = sign( max( 0.000, fAngleThreshold - fAngleFalloff ) );
               //fValid += fDistFactorsaturate( fDistFactor + fAngleThreshold + ;
               //fValidSamples += fValid;
               //fFinalColor += fDistFactor*(1.0-fAngleThreshold);//fOcclusion;//fOcclusion*fAngleThreshold;//*fDistFactor*fAngleThreshold;
	         }

            //return float4( 1,1,1, fFinalColor.x/nSamples );
            //return float4( vNormalVS, 1 );
            //return float4(1,0,0,1);
            return vFinalColor;
            //return float4( vFinalColor.xyz/nSamples * fOcclusionScale, 1 );
            //return float4( 1.0-(vFinalColor.xxx), 1 );
	        //return float4( saturate(1.0-vFinalColor.xxx/nSamples*fOcclusionScale), 1 );
         }

      EndPixelShader
   }
}


// Horizon-Based AO technique
// Based on SIGGRAPH 08 presentation by Louis Bavoil and Miguel Sainz
Technique HorizonBasedSSAO
{
   Pass P0
   {
       RenderTargetFormat = SU_FORMAT_R8_UNORM
       StreamMap = sm1
      CullMode = NONE

      // DEPTH STATE
      ZEnable = false
      ZWriteEnable = false
      //BlendEnable = true

      // Color should multiply
      //SrcBlend = DESTCOLOR
      //DstBlend = ZERO
      //BlendOp = ADD

      //SrcBlendAlpha = ONE
      //DstBlendAlpha = ZERO
      //BlendOpAlpha = ADD

      // Alpha should not change

      VertexShader(HLSL, EntryPoint="VS")
      struct VsInput
      {
        float3 vPosition : Position;
      };

      struct VsOutput
      {
         float4 vPosition   : SV_POSITION;
      };

      $include "Math"
      float4   vCameraProjParams;

      VsOutput VS( VsInput i )
      {
         VsOutput o;

         // We are rendering a full-screen quad here
         o.vPosition = float4( i.vPosition.xy, 0, 1 );

         return o;
      }
      EndVertexShader

      PixelShader(HLSL, EntryPoint="PS")

         struct PsInput
         {
           float4 vPosition   : SV_POSITION;
         };
         Texture2D<float4> tRandom;
         Texture2D<float> tDepth;
         Texture2D<float4> tNormals;
         SamplerState sLinear;
         SamplerState sPoint;

         float4x4 mInvVP;
         float4x4 mInvP;
         float4x4 mV;
         float4x4 mP;

         float4   vCameraProjParams;
         float4   vViewport;
         float    fSampleRadius;
         float    fEpsilon;
         float    fDistFalloff;
         float    fAngleFalloff;
         float    fOcclusionScale;
         float    fDepthFalloff;


         Float g_fR;              
         Float g_fSqrR;           
         Float g_fInvR;           
         Float g_fAttenuation;    
         Float g_fNumDir;         
         Float g_fNumSteps;       
         Float g_fContrast;       
         Float g_fAngleBias;      
         Float g_fTanAngleBias;   

         Vector g_vFocalLen;      


         $include "Transforms"
         $include "SSAOCommon"
         $include "Math"

      float3 FetchViewPos( float2 vUV )
      {
          float fZ = tDepth.SampleLevel( sPoint, vUV, 0 );
          return GetViewSpaceFromUV( vUV, fZ )*float3(1,1,-1);
      }

      // Calculate the intersection with vTangentPlane at vUV
      float3 vTangentViewPos(float2 vUV, float4 vTangentPlane)
      {
          // View vector going through the surface point at uv
          float3 vPosVS = FetchViewPos(vUV);

          // Angle between plane normal and view vector
          float fNdotV = dot( vTangentPlane.xyz, vPosVS );

          // Intersect with tangent plane except for silhouette edges
          if( fNdotV < 0.0 )
             vPosVS *= (vTangentPlane.w / fNdotV); // (tangentPlane.w / NdotV) is the parametric distance along V at which the ray
                                                   // intersects the plane

          return vPosVS;
      }

      float length2(float3 v)
      { 
         return dot(v, v);
      } 

      // Calculate attenuation
      float Attenuation(float r)
      {
          return 1.0f - g_fAttenuation*r*r;
      }

      // Snap an offset in UV space to a pixel center
      float2 SnapOffset(float2 vUV)
      {
          return round(vUV * vViewport.zw) * (1.0/vViewport.zw);
      }

      // Convert tangent to sin
      float TanToSin(float fTan )
      {
          return fTan / sqrt(1.0f + fTan*fTan);
      }

      float3 GetTangentVS( float2 vDeltaUV, float3 vdPdu, float3 vdPdv )
      {
          return vDeltaUV.x * vdPdu + vDeltaUV.y * vdPdv;
      }


      // Calculating the tan of the angle between the tangent plane the view plane
      float Tangent(float3 vT)
      {
          return -vT.z / length(vT.xy);
      }

      float Tangent( float3 vP, float3 vS )
      {
          return ( vP.z - vS.z) / length(vS.xy - vP.xy);
      }

      float GetHorizonOcclusion(float2 vDeltaUV, float2 vCenterUV, float3 vPosVS, float fNumSteps, 
                                float fRandStep, float3 vdPdu, float3 vdPdv, out float3 vTangent )
      {
         // Randomize starting point within the first sample distance
         float2 vUV = vCenterUV + SnapOffset( fRandStep * vDeltaUV );

         // Snap increments to pixels to avoid disparities between xy 
         // and z sample locations and sample along a line
         vDeltaUV = SnapOffset( vDeltaUV );

         // Compute tangent vector using the tangent plane
         float3 vT = GetTangentVS( vDeltaUV, vdPdu, vdPdv );

         float fTanH = Tangent( vT );
         float fSinH = fTanH / sqrt(1.0f + fTanH*fTanH);

         float fAO = 0;
         for(float j = 0; j <= fNumSteps; ++j)
         {
            vUV += vDeltaUV;
            float3 vSampleVS = FetchViewPos(vUV);

            // Ignore any samples outside the radius of influence
            float fDistSq  = length2( vSampleVS - vPosVS );

            if( fDistSq < g_fSqrR )
            {
               float fTanS = Tangent(vPosVS, vSampleVS);

               // This sample is the "most occluding" along this direction
               [branch]
               if( fTanS > fTanH)
               {
                   // Accumulate AO between the horizon and the sample
                   float fSinS = fTanS / sqrt(1.0f + fTanS*fTanS);
                   float fR = sqrt( fDistSq ) * g_fInvR;
                   fAO += Attenuation(fR) * (fSinS - fSinH);
                   
                   // Update the current horizon angle
                   fTanH = fTanS;
                   fSinH = fSinS;
               }
            } 
         }

         vTangent = vT;

         return fAO;
      }


      float4x4 mInvV;
      SamplerState sPointWrap;

      //----------------------------------------------------------------------------------
      float4 PS( PsInput i ) : SV_TARGET
      {
         float2 vUV = i.vPosition/vViewport.zw;

         float3 vPosVS = FetchViewPos( vUV );
         float3 vPosWS = GetWorldSpaceFromUV( vUV, i.vPosition.z );

         // Get radius in texture space.
         // The scaling by 0.5 is to go from [-1,1] to [0,1].
         float2 vStepSize = 0.5 * g_fR  * g_vFocalLen / vPosVS.z;

         // Early out if the projected radius is smaller than a pixel.
         float fNumSteps = min ( g_fNumSteps, min(vStepSize.x * vViewport.z, vStepSize.y * vViewport.w ) );

         //return float4( vStepSize.xxx, 1 );
         if( fNumSteps < 1.0 )
			return float4(1, 1, 1, 1);
            //return float4(0,0,0,1);

         vStepSize = vStepSize / ( fNumSteps + 1 );         

         // Nearest neighbor pixels on the tangent plane
         float3 vPlaneRight, vPlaneLeft, vPlaneTop, vPlaneBottom;
         float4 vTangentPlane;

         // Grab the normals and define the plane
         int2 nCoord = floor(i.vPosition.xy);
         float4 vTmpNormal = tNormals.SampleLevel( sPoint, vUV, 0 );
         float3 vNormalVS = normalize(mul( mV, float4( vTmpNormal.rgb*2.0-1.0, 0 ) ).xyz)*float3(1,1,-1);

         vTangentPlane = float4(vNormalVS, dot(vPosVS, vNormalVS));

         float2 vInvResolution = 1.0/vViewport.zw;
         vPlaneRight  = vTangentViewPos(vUV + float2(  vInvResolution.x, 0 ), vTangentPlane);
         vPlaneLeft   = vTangentViewPos(vUV + float2( -vInvResolution.x, 0 ), vTangentPlane);
         vPlaneTop    = vTangentViewPos(vUV + float2( 0,  vInvResolution.y ), vTangentPlane);
         vPlaneBottom = vTangentViewPos(vUV + float2( 0, -vInvResolution.y ), vTangentPlane);
          
         // Screen aligned basis for the tangent plane
         float3 vRight = vPlaneRight - vPosVS;
         float3 vLeft = vPosVS - vPlaneLeft;
         float3 vdPdu = (length2(vRight) < length2(vLeft)) ? vRight : vLeft;

         float3 vTop = vPlaneTop - vPosVS;
         float3 vBottom = vPosVS - vPlaneBottom;
         float3 vdPdv = (length2(vTop) < length2(vBottom)) ? vTop : vBottom;

         float3 vRand = (tRandom.Load(int3((int)i.vPosition.x&127, (int)i.vPosition.y&127, 0)).xyz);

         float fAO = 0;
         float d;
         float fAlpha = 2.0f * SU_PI / g_fNumDir;

         //float3 vBentNormalVS = vNormalVS;
         float3 vSummedNormal = 0;

         // Loop over sample directions
         for (d = 0; d < g_fNumDir; d++) {
            float fAngle = fAlpha * d;
            float2 vDir = float2(cos(fAngle), sin(fAngle));
            float2 vDeltaUV = rotate_direction(vDir, vRand.xy) * vStepSize.xy;
            float3 vTangent = 0;
            float fTmpAO = GetHorizonOcclusion( vDeltaUV, vUV, vPosVS, fNumSteps, vRand.z, vdPdu, vdPdv, vTangent );
            fAO += fTmpAO;

         }

         return float4( (1.0 - fAO / g_fNumDir * g_fContrast).xxx*vTmpNormal.a, vTmpNormal.a );
      }

      EndPixelShader
   }
}






Technique SetStencil
{
   Pass P0
   {
      StreamMap = sm1
      CullMode = NONE

      // DEPTH STATE
      ZEnable = false
      ZWriteEnable = false
      StencilEnable = true

      StencilFunc        = ALWAYS;
      StencilPassOp      = REPLACE;
      StencilFailOp      = KEEP;
      StencilZFailOp     = KEEP;

      BackStencilFunc    = ALWAYS;
      BackStencilPassOp  = REPLACE;
      BackStencilFailOp  = KEEP;
      BackStencilZFailOp = KEEP;

      StencilRef         = 1;

      VertexShader(HLSL, EntryPoint="VS")
      struct VsInput
      {
        float3 vPosition : Position;
      };

      struct VsOutput
      {
         float4 vPosition   : SV_POSITION;
      };

      $include "Math"
      float4   vCameraProjParams;

      VsOutput VS( VsInput i )
      {
         VsOutput o;

         // We are rendering a full-screen quad here
         o.vPosition = float4( i.vPosition.xy, 0, 1 );

         return o;
      }
      EndVertexShader

      PixelShader(HLSL, EntryPoint="PS")

         struct PsInput
         {
           float4 vPosition   : SV_POSITION;
         };

         Texture2D<float4> tNormals;
         SamplerState sLinear;
         SamplerState sPoint;

         float4 vViewport;

         float4 PS( PsInput i ) : SV_TARGET
         {

            float2 vUV = i.vPosition.xy/vViewport.zw;

            float fValue = tNormals.SampleLevel( sLinear, vUV, 0 ).a;


            if( fValue > 0 )
               return 1;
            else
               clip(-1);

            return 1;
         }

      EndPixelShader
   }
}

Technique StenciledSSAO : SSAO
{
   Pass P0
   {
      StencilEnable = true;

      StencilRef         = 1;

      StencilFunc        = EQUAL;
      StencilPassOp      = KEEP;
      StencilFailOp      = KEEP;
      StencilZFailOp     = KEEP;

      BackStencilFunc    = EQUAL;
      BackStencilPassOp  = KEEP;
      BackStencilFailOp  = KEEP;
      BackStencilZFailOp = KEEP;
   }
}

Technique StenciledHorizonBasedSSAO : HorizonBasedSSAO
{
   Pass P0
   {
      StencilEnable = true;

      SrcBlend = ONE
      DstBlend = ZERO
      BlendOp = ADD

      StencilRef         = 1;

      StencilFunc        = EQUAL;
      StencilPassOp      = KEEP;
      StencilFailOp      = KEEP;
      StencilZFailOp     = KEEP;

      BackStencilFunc    = EQUAL;
      BackStencilPassOp  = KEEP;
      BackStencilFailOp  = KEEP;
      BackStencilZFailOp = KEEP;
   }
}

Technique BlurX
{
   Pass P0
   {
       RenderTargetFormat = SU_FORMAT_R8_UNORM
       StreamMap = sm1
      CullMode = NONE

      // DEPTH STATE
      ZEnable = false
      ZWriteEnable = false
      BlendEnable = false;


      VertexShader(HLSL, EntryPoint="VS")
      struct VsInput
      {
        float3 vPosition : Position;
      };

      struct VsOutput
      {
         float4 vPosition   : SV_POSITION;
      };

      $include "Math"
      float4   vCameraProjParams;

      VsOutput VS( VsInput i )
      {
         VsOutput o;

         // We are rendering a full-screen quad here
         o.vPosition = float4( i.vPosition.xy, 0, 1 );

         return o;
      }
      EndVertexShader

      PixelShader(HLSL, EntryPoint="PS")

         struct PsInput
         {
           float4 vPosition   : SV_POSITION;
         };

         Texture2D<float> tDepth;
         Texture2D<float4> tAO;
         SamplerState sLinear;
         SamplerState sPoint;

         float4x4 mInvVP;
         float4x4 mInvP;
         float4x4 mV;
         float4x4 mP;
         float4   vViewport;
         float4   vCameraProjParams;
         bool     bBlur;
         float    fBlurRadius;

         $include "Math"
         $include "Transforms"
         $include "Bilateral"

         float4 PS( PsInput i ) : SV_TARGET
         {

            float2 vUV = i.vPosition.xy/vViewport.zw;

            float fSum = 0;
            float fCumulativeWeight = 0;
            
            float4 vValue = tAO.SampleLevel( sPoint, vUV, 0 );
            float fAO = vValue.x;
	         float fDepth = tDepth.SampleLevel( sPoint, vUV, 0 );
            float fLinearDepth = -GetViewSpaceFromUV( vUV, fDepth ).z;
            //fLinearDepth /= -(vCameraProjParams.w - vCameraProjParams.z); //0..1

            //const float fRadius = 19;
			const float fRadius = fBlurRadius;

            for( int j=-fRadius; j<fRadius; j++ )
            {
               fSum += ApplyFilter( vUV, j, 0, fAO, fLinearDepth,  fCumulativeWeight );
            }
         
            return float4((fSum/fCumulativeWeight).xxx, vValue.a );
         }

      EndPixelShader
   }
}

Technique BlurY : BlurX
{
   Pass P0
   {
      StreamMap = sm1
      CullMode = NONE

      // DEPTH STATE
      ZEnable = false
      ZWriteEnable = false
      BlendEnable = false;

      PixelShader(HLSL, EntryPoint="PS")

         struct PsInput
         {
           float4 vPosition   : SV_POSITION;
         };


         Texture2D<float4> tAO;
         Texture2D<float> tDepth;
         SamplerState sLinear;
         SamplerState sPoint;

         float4x4 mInvVP;
         float4x4 mInvP;
         float4x4 mV;
         float4x4 mP;
         float4   vViewport;
         float4   vCameraProjParams;
         bool     bBlur;
         float    fBlurRadius;
         $include "Math"
         $include "Transforms"
         $include "Bilateral"

         float4 PS( PsInput i ) : SV_TARGET
         {

            float2 vUV = i.vPosition.xy/vViewport.zw;

            float3 fSum = 0;
            float fCumulativeWeight = 0;

            float4 vValue = tAO.SampleLevel( sPoint, vUV, 0 );
            float fAO = vValue.x;
	         float fDepth = tDepth.SampleLevel( sPoint, vUV, 0 );
            float fLinearDepth = -GetViewSpaceFromUV( vUV, fDepth ).z;
            //fLinearDepth /= -(vCameraProjParams.w - vCameraProjParams.z); //0..1
            //const float fRadius = 19;
			const float fRadius = fBlurRadius;

            for( int j=-fRadius; j<fRadius; j++ )
            {
               fSum += ApplyFilter( vUV, j, 1, fAO, fLinearDepth,  fCumulativeWeight );
            }

            return float4((fSum/fCumulativeWeight).xxx, vValue.a );
         }

      EndPixelShader
   }
}