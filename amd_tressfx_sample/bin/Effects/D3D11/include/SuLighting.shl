//=================================================================================================================================
//
// Author: Thorsten Scheuermann
//         3D Application Research Group
//         ATI Research, Inc.
//
// Standard direct lighting code
//=================================================================================================================================
// $Id: //depot/3darg/Demos/Effects/TressFXRelease/amd_tressfx_sample/bin/Effects/D3D11/include/SuLighting.shl#1 $ 
// 
// Last check-in:  $DateTime: 2017/03/28 18:02:41 $ 
// Last edited by: $Author: khillesl $
//=================================================================================================================================
//   (C) ATI Research, Inc. 2006 All rights reserved. 
//=================================================================================================================================

// This makes stuff go faster. All the tiny branches in the lighting code seem to be a bad idea.
#ifndef SU_CRAZY_IF
#define SU_CRAZY_IF [flatten] if
#endif

/*
   Supported #defines:
      SU_MAX_LIGHTS              Maximum number of lights to support
      SU_NO_LIGHT_DROPOFF        Don't compute Maya-style spotlight dropoff
      SU_NO_LIGHT_FALLOFF        Skip light falloff computation
 */

#ifndef SU_MAX_LIGHTS
#define SU_MAX_LIGHTS 20
#endif

// INCLUDES =======================================================================================================================
#include "SuMath.shl"
#include "SuGamma.shl"

// PARAMETERS =====================================================================================================================

Int    nNumLights <AppUpdate = NumLights >
Int    nLightShape[ SU_MAX_LIGHTS ] <AppUpdate = LightShape >
Int    nLightIndex[ SU_MAX_LIGHTS ] <AppUpdate = LightIndex >
Float fLightIntensity[SU_MAX_LIGHTS ] <AppUpdate = LightIntensity >
Vector vLightPosWS[ SU_MAX_LIGHTS ] <AppUpdate = LightPosition >
Vector vLightDirWS[ SU_MAX_LIGHTS ] <AppUpdate = LightDirection >
Vector vLightConeAngles[ SU_MAX_LIGHTS ] <AppUpdate = LightConeAngles >
Vector vLightScaleWS[ SU_MAX_LIGHTS ] <AppUpdate = LightScale >
Vector vLightParams[ SU_MAX_LIGHTS ] <AppUpdate = LightParams >
Vector vLightOrientationWS[ SU_MAX_LIGHTS ] <AppUpdate = LightOrientation>

#ifndef SU_LINEAR_SPACE_LIGHTING
   Vector vLightColor[ SU_MAX_LIGHTS ] <AppUpdate = LightColor >
#endif

#ifdef SU_LINEAR_SPACE_LIGHTING
   Vector vLightColor[ SU_MAX_LIGHTS ] <AppUpdate = LightColor, colorConversion = < exponent=SU_sRGB_TO_LINEAR, mask="RGB" > >
#endif

// HLSL ===========================================================================================================================

StartHLSL "SuLighting"

   $include "Math"
   $include "MathQuaternion"
   $include "MathMatrix"

   // =============================================================================================================================
   static const int POINT_LIGHT = 0;
   static const int DIRECTIONAL_LIGHT = 1;
   static const int SPOT_LIGHT = 2;
   static const int VOLUME_LIGHT = 3;

   static const int VOLUME_LIGHT_SPHERE = 1;
   static const int VOLUME_LIGHT_CONE = 3;

   uniform int nNumLights;
   uniform int nLightShape[ SU_MAX_LIGHTS ];
   uniform int nLightIndex[ SU_MAX_LIGHTS ];
   uniform float fLightIntensity[ SU_MAX_LIGHTS ];
   uniform float3 vLightPosWS[ SU_MAX_LIGHTS ];
   uniform float3 vLightDirWS[ SU_MAX_LIGHTS ];
   uniform float3 vLightColor[ SU_MAX_LIGHTS ];
   uniform float3 vLightConeAngles[ SU_MAX_LIGHTS ];
   uniform float3 vLightScaleWS[ SU_MAX_LIGHTS ];
   uniform float4 vLightParams[ SU_MAX_LIGHTS ];
   uniform float4 vLightOrientationWS[ SU_MAX_LIGHTS ];


   // =============================================================================================================================
   float SuComputeSpotLightAttenuation( float3 vLightVecWS, int nLightID )
   {
      // spotlight falloff
      float fCosLightAngle = dot( -vLightVecWS, vLightDirWS[nLightID] );
      float fAttenuation = smoothstep( vLightConeAngles[nLightID].x, vLightConeAngles[nLightID].y, fCosLightAngle );
      
      #ifndef SU_NO_LIGHT_DROPOFF
         // dropoff
         fAttenuation *= SuPow( fCosLightAngle, vLightConeAngles[nLightID].z );
      #endif

      return fAttenuation;
   }

   // =============================================================================================================================
   float SuComputeLightFalloff( float fLightDistance, int nLightID )
   {
      #ifdef SU_NO_LIGHT_FALLOFF
         return 1.0;
      #else
         return SuPow( fLightDistance, -vLightParams[nLightID].y ); // lightParams.y is falloff exponent
      #endif
   }

   	// =============================================================================================================================
	bool SuIsVolume( int nLightID )
	{
		return ( vLightParams[nLightID].x == VOLUME_LIGHT );
	}


	 // =============================================================================================================================
	float3 SuComputeVolumeAmbient( float3 vPositionWS, int nLightID )
	{
		// Inverse Transform
		float4x4 mInverseRotation = SuTransposeMatrix(SuQuatToMatrix(vLightOrientationWS[nLightID]));
		float4x4 mInverseScale = SuMakeScaleMatrix(1.0f/vLightScaleWS[nLightID].x,
		                                           1.0f/vLightScaleWS[nLightID].y, 
		                                           1.0f/vLightScaleWS[nLightID].z);
		float4x4 mInverseTransform = SuMult44x44(mInverseScale, mInverseRotation);
		
		// Compute attenuation
		float3 vPositionLS = SuMult44x31(mInverseTransform, vPositionWS-vLightPosWS[nLightID]);
		float fDist = length(vPositionLS);
		
		SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_SPHERE )
		{
			if(fDist < 1 + SU_EPSILON)
				return fLightIntensity[nLightID] * vLightColor[nLightID];
		}
		
		else SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_CONE )
		{
			float fHeight = -vPositionLS.y;
			if( ( 0.0f - SU_EPSILON < fHeight ) && ( fHeight < 1.0f + SU_EPSILON ) )
			{
				float fDist = length( float2(vPositionLS.x, vPositionLS.z) );
				if( fDist < fHeight )
					return fLightIntensity[nLightID] * vLightColor[nLightID];
			}
		}
		
		return float3(0,0,0);
	}



	// =============================================================================================================================

	float SuComputeVolumeLightFalloff( float3 vPositionWS, int nLightID )
	{
		// Inverse Transform
		float4x4 mInverseRotation = SuTransposeMatrix(SuQuatToMatrix(vLightOrientationWS[nLightID]));
		float4x4 mInverseScale = SuMakeScaleMatrix(1.0f/vLightScaleWS[nLightID].x,
		                                           1.0f/vLightScaleWS[nLightID].y, 
		                                           1.0f/vLightScaleWS[nLightID].z);
		float4x4 mInverseTransform = SuMult44x44(mInverseScale, mInverseRotation);
		
		// Compute attenuation
		float3 vPositionLS = SuMult44x31(mInverseTransform, vPositionWS-vLightPosWS[nLightID]);
		float fDist = length(vPositionLS);
		float fAttenuation = 1.0;	
		
		SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_SPHERE )
		{
			if(fDist < 1 + SU_EPSILON)
			{
			   fAttenuation = 1-fDist;
			}
		}
		
		else SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_CONE )
		{
			float fHeight = -vPositionLS.y;
			if( ( 0.0f - SU_EPSILON < fHeight ) && ( fHeight < 1.0f + SU_EPSILON ) )
			{
				float fDist = length( float2(vPositionLS.x, vPositionLS.z) );
				if( fDist < fHeight )
				{
					fAttenuation = 1 - (fDist/fHeight);
				}
			}
		}
		
		return fAttenuation;
	}

   // =============================================================================================================================
   float3 SuGetVectorToLightPoint( float3 vPositionWS, int nLightID )
   {
      return normalize( vLightPosWS[nLightID] - vPositionWS );
   }

   // =============================================================================================================================
   float3 SuGetVectorToLightDirectional( int nLightID )
   {
      return -vLightDirWS[nLightID];
   }

   // =============================================================================================================================
   float3 SuGetVectorToLight( float3 vPositionWS, int nLightID )
   {
      SU_CRAZY_IF( vLightParams[nLightID].x != DIRECTIONAL_LIGHT )
      {
         return SuGetVectorToLightPoint( vPositionWS, nLightID );
      }
      else 
      {
         return SuGetVectorToLightDirectional( nLightID );
      }
   }

   // =============================================================================================================================
   // Reduces light to a direction and scaled color (taking attenuation and light strenght into account)
   void SuGetLightLocal( float3 vPositionWS, int nLightID, out float3 vLightOutDirWS, out float3 cAttenulatedColor)
   {
      float fIntensity = fLightIntensity[nLightID];
      SU_CRAZY_IF( vLightParams[nLightID].x == DIRECTIONAL_LIGHT )
      {
         vLightOutDirWS = -vLightDirWS[nLightID];
         cAttenulatedColor = fIntensity * vLightColor[nLightID];
         return;
      }
      
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      vLightOutDirWS = normalize(vLightVecWS);
      
      SU_CRAZY_IF( vLightParams[nLightID].x == VOLUME_LIGHT )
      {
         fIntensity *= SuComputeVolumeLightFalloff(vPositionWS, nLightID);
      }
      else
      {
         fIntensity *= SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      }
      
      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         fIntensity *= SuComputeSpotLightAttenuation( normalize(vLightVecWS), nLightID );
      }
      
      cAttenulatedColor = fIntensity*vLightColor[nLightID];
      return;
   }

   // =============================================================================================================================
   float3 SuGetLightColor( float3 vPositionWS, int nLightID )
   {
      float3 cColor;
      SU_CRAZY_IF( vLightParams[nLightID].x == DIRECTIONAL_LIGHT )
      {
         cColor = vLightColor[nLightID];
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
         cColor = vLightColor[nLightID]*SuComputeLightFalloff( length( vLightVecWS ), nLightID );
         cColor *= SuComputeSpotLightAttenuation( normalize(vLightVecWS), nLightID );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
         cColor = vLightColor[nLightID]*SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      }

      return cColor;
   }


   // =============================================================================================================================
   // DIFFUSE LIGHTING
   // =============================================================================================================================

   // =============================================================================================================================
   float3 SuComputeDiffusePointLight( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      // we could do the whole computation conditionally based on the diffuse mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fDiffuse = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fDiffuse *= saturate( dot( vLightVecWS, vNormalWS ) );
      
      return fDiffuse * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeDiffuseSpotLight( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      // we could do the whole computation conditionally based on the diffuse mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fDiffuse = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fDiffuse *= saturate( dot( vLightVecWS, vNormalWS ) );
      fDiffuse *= SuComputeSpotLightAttenuation( vLightVecWS, nLightID );

      return fDiffuse * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeDiffuseDirectionalLight( float3 vNormalWS, int nLightID )
   {
      // falloff doesn't make any sense for directional light sources
      float fDiffuse = saturate( dot( -vLightDirWS[nLightID], vNormalWS ) );

      return fDiffuse * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeDiffuse( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      float3 cDiffuse;

      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         cDiffuse = SuComputeDiffuseSpotLight( vPositionWS, vNormalWS, nLightID );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         cDiffuse = SuComputeDiffusePointLight( vPositionWS, vNormalWS, nLightID );
      }
	  else
      {
         cDiffuse = SuComputeDiffuseDirectionalLight( vNormalWS, nLightID );
      }

      return cDiffuse;
   }

   // =============================================================================================================================
   // SPECULAR LIGHTING
   // =============================================================================================================================

   // =============================================================================================================================
   //            PHONG LIGHTING
   // =============================================================================================================================   
   // =============================================================================================================================
   float3 SuComputeSpecularPointLightPhong( float3 vPositionWS, float3 vReflectedViewWS, float fSpecExp, int nLightID )
   {
      // we could do the whole computation conditionally based on the specular mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fSpec = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fSpec *= SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }

   // =============================================================================================================================
   float3 SuComputeSpecularSpotLightPhong( float3 vPositionWS, float3 vReflectedViewWS, float fSpecExp, int nLightID )
   {
      // we could do the whole computation conditionally based on the specular mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fSpec = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fSpec *= SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      fSpec *= SuComputeSpotLightAttenuation( vLightVecWS, nLightID );
      
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }

   // =============================================================================================================================
   float3 SuComputeSpecularDirectionalLightPhong( float3 vReflectedViewWS, float fSpecExp, int nLightID )
   {
      // we could do the whole computation conditionally based on the specular mask
      float fSpec = SuPow( saturate( dot( -vLightDirWS[nLightID], vReflectedViewWS ) ), fSpecExp );
      
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }

   // =============================================================================================================================
   float3 SuComputeSpecularPhong( float3 vPositionWS, float3 vReflectedViewWS, float fSpecExp, int nLightID )
   {
      float3 cSpec;

      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         cSpec = SuComputeSpecularSpotLightPhong( vPositionWS, vReflectedViewWS, fSpecExp, nLightID );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         cSpec = SuComputeSpecularPointLightPhong( vPositionWS, vReflectedViewWS, fSpecExp, nLightID );
      }
	  else
      {
         cSpec = SuComputeSpecularDirectionalLightPhong( vReflectedViewWS, fSpecExp, nLightID );
      }

      return cSpec;
   }
   // =============================================================================================================================
   //            TORRANCE-SPARROW LIGHTING
   // ============================================================================================================================= 
   //===========================================================================================================
   // Torrance-Sparrow with Blinn microfacet distribution (aka Blinn-Phong)
   // exponent = phong exponent for highlight
   //===========================================================================================================   
   float GeometryDist( float NdotH, float NdotV, float VdotH, float NdotL )
   {
      return min( 1.0, min( 2 * (NdotH) * (NdotV) / (VdotH), 2 * (NdotH) * (NdotL) / (VdotH) ) );
   }
      
   float MicrofacetDist( float exponent, float NdotH )
   {
         return SuPow( saturate( NdotH ),  exponent );
   }
   // =============================================================================================================================
   float3  SuComputeSpecularPointLightTSB( float3 vPositionWS, float3 vNormalWS, float3 vViewWS,  
                                           float fSpecExp, int nLightID )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;
      
      // we could do the whole computation conditionally based on the specular mask
      float3 vLightWS = vLightPosWS[nLightID] - vPositionWS;
      float fSpec = SuComputeLightFalloff( length( vLightWS ), nLightID );
      vLightWS = normalize( vLightWS );
   
      // Calculate half vector between light and view
      float3 vHalfWS = ( vLightWS + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, vLightWS );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );
      
      // Calculate specular and diffuse
      fSpec *= D * G * F / NdotV;
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }
   // =============================================================================================================================
   float3  SuComputeSpecularSpotLightTSB(  float3 vPositionWS, float3 vNormalWS, float3 vViewWS,  
                                           float fSpecExp, int nLightID )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;
      
      // we could do the whole computation conditionally based on the specular mask
      float3 vLightWS = vLightPosWS[nLightID] - vPositionWS;
      float fSpec = SuComputeLightFalloff( length( vLightWS ), nLightID );
      vLightWS = normalize( vLightWS );
      
      // Calculate half vector between light and view
      float3 vHalfWS = ( vLightWS + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, vLightWS );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );
      
      // Calculate specular
      fSpec *= D * G * F / NdotV;
      fSpec *= SuComputeSpotLightAttenuation( vLightWS, nLightID );
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }

   // =============================================================================================================================
   float3 SuComputeSpecularDirectionalLightTSB( float3 vNormalWS, float3 vViewWS, float fSpecExp, int nLightID )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;   
   
      // Calculate half vector between light and view
      float3 vHalfWS = ( -vLightDirWS[nLightID] + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, -vLightDirWS[nLightID] );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );
      
      // we could do the whole computation conditionally based on the specular mask
      float fSpec = D * G * F / NdotV;
      
      return fSpec * vLightColor[nLightID] * vLightParams[nLightID].w;   // vLightParams.w is the specular mask
   }

   // =============================================================================================================================
   float3 SuComputeSpecularTSB( float3 vPositionWS, float3 vNormalWS, float3 vViewWS, float fSpecExp, int nLightID )
   {
      float3 cSpec;

      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         cSpec = SuComputeSpecularSpotLightTSB( vPositionWS, vNormalWS, vViewWS, fSpecExp, nLightID );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         cSpec = SuComputeSpecularPointLightTSB( vPositionWS, vNormalWS, vViewWS, fSpecExp, nLightID );
      }
      else
      {
         cSpec = SuComputeSpecularDirectionalLightTSB( vNormalWS, vViewWS, fSpecExp, nLightID );
      }

      return cSpec;
   }  
   // =============================================================================================================================
   // COMBINED DIFFUSE SPECULAR
   // ============================================================================================================================= 
   // =============================================================================================================================
   //===========================================================================================================
   //       COMBINED PHONG
   //===========================================================================================================      
   void SuComputeDiffuseSpecPointLightPhong( float3 vPositionWS,
                                             float3 vNormalWS,
                                             float3 vReflectedViewWS,
                                             float fSpecExp,
                                             int nLightID,
                                             out float3 cDiffuse,
                                             out float3 cSpecular )
   {
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fFalloff = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      float2 vDS;
      vDS.x = saturate( dot( vLightVecWS, vNormalWS ) );
      vDS.y = SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      vDS *= vLightParams[nLightID].zw;
      vDS *= fFalloff;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecSpotLightPhong( float3 vPositionWS,
                                            float3 vNormalWS,
                                            float3 vReflectedViewWS,
                                            float fSpecExp,
                                            int nLightID,
                                            out float3 cDiffuse,
                                            out float3 cSpecular )
   {
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fFalloff = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      float2 vDS;
      vDS.x = saturate( dot( vLightVecWS, vNormalWS ) );      
      vDS.y = SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      vDS *= SuComputeSpotLightAttenuation( vLightVecWS, nLightID );
      vDS *= vLightParams[nLightID].zw;
      vDS *= fFalloff;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecDirectionalLightPhong( float3 vNormalWS,
                                                   float3 vReflectedViewWS,
                                                   float fSpecExp,
                                                   int nLightID,
                                                   out float3 cDiffuse,
                                                   out float3 cSpecular )
   {
      float2 vDS;
      vDS.x = saturate( dot( -vLightDirWS[nLightID], vNormalWS ) );
      vDS.y = SuPow( saturate( dot( -vLightDirWS[nLightID], vReflectedViewWS ) ), fSpecExp );
      vDS *= vLightParams[nLightID].zw;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   void SuComputeDiffuseSpecVolumeLightSpherePhong( float3 vPositionWS,
                                             float3 vNormalWS,
                                             float3 vReflectedViewWS,
                                             float fSpecExp,
                                             int nLightID,
                                             out float3 cDiffuse,
                                             out float3 cSpecular )
   {
      // Inverse Transform
      float4x4 mInverseRotation = SuTransposeMatrix(SuQuatToMatrix(vLightOrientationWS[nLightID]));
      float4x4 mInverseScale = SuMakeScaleMatrix(1.0f/vLightScaleWS[nLightID].x,
                                                 1.0f/vLightScaleWS[nLightID].y, 
                                                 1.0f/vLightScaleWS[nLightID].z);
      float4x4 mInverseTransform = SuMult44x44(mInverseScale, mInverseRotation);

      // Compute attenuation
      float3 vPositionLS = SuMult44x31(mInverseTransform, vPositionWS-vLightPosWS[nLightID]);
      float fDist = length(vPositionLS);
      float fAttenuation = 0;

      if(fDist < 1 + SU_EPSILON)
      {
         fAttenuation = 1-fDist;
      }

      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      vLightVecWS = normalize( vLightVecWS );
      float2 vDS;
      vDS.x = saturate( dot( vLightVecWS, vNormalWS ) );      
      vDS.y = SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      vDS *= vLightParams[nLightID].zw;
      vDS *= fAttenuation;

      cDiffuse  = vDS.x * vLightColor[nLightID] * fLightIntensity[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID] * fLightIntensity[nLightID];
   }

   void SuComputeDiffuseSpecVolumeLightConePhong( float3 vPositionWS,
                                                  float3 vNormalWS,
                                                  float3 vReflectedViewWS,
                                                  float fSpecExp,
                                                  int nLightID,
                                                  out float3 cDiffuse,
                                                  out float3 cSpecular )
   {
      // Inverse Transform
      float4x4 mInverseRotation = SuTransposeMatrix(SuQuatToMatrix(vLightOrientationWS[nLightID]));
      float4x4 mInverseScale = SuMakeScaleMatrix(1.0f/vLightScaleWS[nLightID].x,
                                                 1.0f/vLightScaleWS[nLightID].y, 
                                                 1.0f/vLightScaleWS[nLightID].z);
      float4x4 mInverseTransform = SuMult44x44(mInverseScale, mInverseRotation);

      // Compute attenuation
      float3 vPositionLS = SuMult44x31(mInverseTransform, vPositionWS-vLightPosWS[nLightID]);

      float fAttenuation = 0;
      float fHeight = -vPositionLS.y;
      if( ( 0.0f - SU_EPSILON < fHeight ) && ( fHeight < 1.0f + SU_EPSILON ) )
      {
         float fDist = length( float2(vPositionLS.x, vPositionLS.z) );
         if( fDist < fHeight )
      {
         fAttenuation = 1 - (fDist/fHeight);
      }
      }

      float3 vLightVecWS = vPositionWS-vLightPosWS[nLightID];
      vLightVecWS = normalize( vLightVecWS );
      float2 vDS;
      vDS.x = saturate( dot( vLightVecWS, vNormalWS ) );      
      vDS.y = SuPow( saturate( dot( vLightVecWS, vReflectedViewWS ) ), fSpecExp );
      vDS *= vLightParams[nLightID].zw;
      vDS *= fAttenuation;
      
      cDiffuse  = vDS.x * vLightColor[nLightID] * fLightIntensity[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID] * fLightIntensity[nLightID];
   }

   void SuComputeDiffuseSpecVolumeLightPhong( float3 vPositionWS,
                                   float3 vNormalWS,
                                   float3 vReflectedViewWS,
                                   float fSpecExp,
                                   int nLightID,
                                   out float3 cDiffuse,
                                   out float3 cSpecular )
   {
      SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_SPHERE )
      {
         SuComputeDiffuseSpecVolumeLightSpherePhong( vPositionWS, vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else SU_CRAZY_IF( nLightShape[nLightID] == VOLUME_LIGHT_CONE )
      {
         SuComputeDiffuseSpecVolumeLightConePhong( vPositionWS, vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else
      {
         //not supported
         cDiffuse = float3(1,0,1);
         cSpecular = float3(0,0,0);
      }
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecPhong( float3 vPositionWS,
                                   float3 vNormalWS,
                                   float3 vReflectedViewWS,
                                   float fSpecExp,
                                   int nLightID,
                                   out float3 cDiffuse,
                                   out float3 cSpecular )
   {
      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         SuComputeDiffuseSpecSpotLightPhong( vPositionWS, vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         SuComputeDiffuseSpecPointLightPhong( vPositionWS, vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == VOLUME_LIGHT )
      {
         SuComputeDiffuseSpecVolumeLightPhong( vPositionWS, vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else
      {
         SuComputeDiffuseSpecDirectionalLightPhong( vNormalWS, vReflectedViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecPhong( float3 vPositionWS,
                                   float3 vNormalWS,
                                   float3 vViewWS,
                                   float fSpecExp,
                                   out float3 cDiffuse,
                                   out float3 cSpecular )
   {
      float3 vReflWS = SuReflect( vViewWS, vNormalWS );

      cDiffuse = float3( 0, 0, 0 );
      cSpecular = float3( 0, 0, 0 );

      float3 cDiff;
      float3 cSpec;

      for( int i = 0; i < nNumLights; i++ )
      {
         SuComputeDiffuseSpecPhong( vPositionWS, vNormalWS, vReflWS, fSpecExp, i, cDiff, cSpec );
         cDiffuse += cDiff;
         cSpecular += cSpec;
      }
   }

   //===========================================================================================================
   //       COMBINED TSB
   //===========================================================================================================      
   void SuComputeDiffuseSpecPointLightTSB ( float3 vPositionWS,
                                            float3 vNormalWS,
                                            float3 vViewWS,
                                            float fSpecExp,
                                            int nLightID,
                                            out float3 cDiffuse,
                                            out float3 cSpecular )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;
         
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fFalloff = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      
      // Calculate half vector between light and view
      float3 vHalfWS = ( vLightVecWS + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, vLightVecWS );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );
      
      float2 vDS;
      vDS.x = saturate( NdotL );
      vDS.y = D * G * F / NdotV;
      vDS *= vLightParams[nLightID].zw;
      vDS *= fFalloff;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecSpotLightTSB( float3 vPositionWS,
                                            float3 vNormalWS,
                                            float3 vViewWS,
                                            float fSpecExp,
                                            int nLightID,
                                            out float3 cDiffuse,
                                            out float3 cSpecular )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;   
   
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fFalloff = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      
       // Calculate half vector between light and view
      float3 vHalfWS = ( vLightVecWS + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, vLightVecWS );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );
      
      float2 vDS;
      vDS.x = saturate( NdotL );      
      vDS.y = D * G * F / NdotV;
      vDS *= SuComputeSpotLightAttenuation( vLightVecWS, nLightID );
      vDS *= vLightParams[nLightID].zw;
      vDS *= fFalloff;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecDirectionalLightTSB( float3 vNormalWS,
                                                   float3 vViewWS,
                                                   float fSpecExp,
                                                   int nLightID,
                                                   out float3 cDiffuse,
                                                   out float3 cSpecular )
   {
      // This is just a test.. may want to hardcode it later
      float fR = 1.0/fSpecExp;
      
      // Calculate half vector between light and view
      float3 vHalfWS = ( -vLightDirWS[nLightID] + vViewWS );
      vHalfWS /= length( vHalfWS );  
      
      // Calculate all the angles we need
      float NdotH = dot( vNormalWS, vHalfWS );
      float NdotV = dot( vNormalWS, vViewWS );
      float VdotH = dot( vViewWS, vHalfWS );
      float NdotL = dot( vNormalWS, -vLightDirWS[nLightID] );  
        
      // Calculate microfacet distribution, masking term, and fresnel
      float G = GeometryDist( NdotH, NdotV, VdotH, NdotL );
      float D = MicrofacetDist( fSpecExp, NdotH );
      float F = SchlickFresnel( NdotV, fR );  
      
      float2 vDS;
      vDS.x = saturate( NdotL );
      vDS.y = D * G * F / NdotV;
      vDS *= vLightParams[nLightID].zw;
      
      cDiffuse  = vDS.x * vLightColor[nLightID];
      cSpecular = vDS.y * vLightColor[nLightID];
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecTSB( float3 vPositionWS,
                                   float3 vNormalWS,
                                   float3 vViewWS,
                                   float fSpecExp,
                                   int nLightID,
                                   out float3 cDiffuse,
                                   out float3 cSpecular )
   {
      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         SuComputeDiffuseSpecSpotLightTSB( vPositionWS, vNormalWS, vViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         SuComputeDiffuseSpecPointLightTSB( vPositionWS, vNormalWS, vViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
      else
      {
         SuComputeDiffuseSpecDirectionalLightTSB( vNormalWS, vViewWS, fSpecExp, nLightID, cDiffuse, cSpecular );
      }
   }

   // =============================================================================================================================
   void SuComputeDiffuseSpecTSB( float3 vPositionWS,
                                  float3 vNormalWS,
                                  float3 vViewWS,
                                  float fSpecExp,
                                  out float3 cDiffuse,
                                  out float3 cSpecular )
   {
      float3 vReflWS = SuReflect( vViewWS, vNormalWS );
      cDiffuse = float3( 0, 0, 0 );
      cSpecular = float3( 0, 0, 0 );

      float3 cDiff;
      float3 cSpec;

      for( int i = 0; i < nNumLights; i++ )
      {
         SuComputeDiffuseSpecTSB( vPositionWS, vNormalWS, vReflWS, fSpecExp, i, cDiff, cSpec );
         cDiffuse += cDiff;
         cSpecular += cSpec;
      }
   }
   // =============================================================================================================================
   // TERMINATOR LIGHTING
   // =============================================================================================================================

   // =============================================================================================================================
   float3 SuComputeTerminatorPointLight( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      // we could do the whole computation conditionally based on the diffuse mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fTerminator = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fTerminator *= ( 1.0 - abs( dot( vLightVecWS, vNormalWS ) ) );
      
      return fTerminator * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeTerminatorSpotLight( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      // we could do the whole computation conditionally based on the diffuse mask
      float3 vLightVecWS = vLightPosWS[nLightID] - vPositionWS;
      float fTerminator = SuComputeLightFalloff( length( vLightVecWS ), nLightID );
      vLightVecWS = normalize( vLightVecWS );
      fTerminator *= ( 1.0 - abs( dot( vLightVecWS, vNormalWS ) ) );
      fTerminator *= SuComputeSpotLightAttenuation( vLightVecWS, nLightID );

      return fTerminator * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeTerminatorDirectionalLight( float3 vNormalWS, int nLightID )
   {
      // falloff doesn't make any sense for directional light sources
      float fTerminator = ( 1.0 - abs( dot( -vLightDirWS[nLightID], vNormalWS ) ) );

      return fTerminator * vLightColor[nLightID] * vLightParams[nLightID].z;   // vLightParams.z is the diffuse mask
   }

   // =============================================================================================================================
   float3 SuComputeTerminator( float3 vPositionWS, float3 vNormalWS, int nLightID )
   {
      float3 cTerminator;

      SU_CRAZY_IF( vLightParams[nLightID].x == SPOT_LIGHT )
      {
         cTerminator = SuComputeTerminatorSpotLight( vPositionWS, vNormalWS, nLightID );
      }
      else SU_CRAZY_IF( vLightParams[nLightID].x == POINT_LIGHT )
      {
         cTerminator = SuComputeTerminatorPointLight( vPositionWS, vNormalWS, nLightID );
      }
      else
      {
         cTerminator = SuComputeTerminatorDirectionalLight( vNormalWS, nLightID );
      }

      return cTerminator;
   }

EndHLSL
