//=================================================================================================================================
//
// Author: Chris Oat
//         3D Application Research Group
//         ATI Research, Inc.
//
//=================================================================================================================================
// $Id: //depot/3darg/Demos/Effects/TressFXRelease/amd_tressfx_sample/bin/Effects/D3DCommon/Include/SuMath.shl#1 $ 
// 
// Last check-in:  $DateTime: 2017/03/28 18:02:41 $ 
// Last edited by: $Author: khillesl $
//=================================================================================================================================
//   (C) ATI Research, Inc. 2006 All rights reserved. 
//=================================================================================================================================


// INCLUDES =======================================================================================================================

// MISC ===========================================================================================================================

// TEXTURES =======================================================================================================================

// PARAMETERS =====================================================================================================================

// STREAMS ========================================================================================================================

// HLSL ===========================================================================================================================

//=============================================================================
// Misc math functions
//=============================================================================
StartHLSL Math

   #define SU_HALF_PI 1.57079632679
   #define SU_PI 3.14159265359
   #define SU_2PI 6.28318530718
   #define SU_SQRT_PI 1.772453851
   #define SU_SQRT2 1.41421356237
   #define SU_EPSILON 1.e-7
   #define SU_EPSILON_FLOAT 1.e-4
   #define SU_MAX_FLOAT 1.e37

   ////////////////////////////////////////////////////////////////////////////
   // Compute the [0,1] clamped dot3 for vec0 and vec1 
   ////////////////////////////////////////////////////////////////////////////
   float SuDot3Clamp (float3 vec0, float3 vec1)
   {
      return saturate (dot (vec0, vec1));
   }

   ////////////////////////////////////////////////////////////////////////////
   // SuPow(x,y)
   // Returns pow( abs(x), y )
   ////////////////////////////////////////////////////////////////////////////
   
   #ifdef SU_3D_API_D3D9
      #define SuPow(x,y) pow(x,y)
   #else
      #define SuPow(x,y) pow( abs(x), y )
   #endif
      
   ////////////////////////////////////////////////////////////////////////////
   // SuSqrt(x)
   //  Returns sqrt( abs(x) )
   //  This function is provided to match the D3D9 sqrt() behavior
   ////////////////////////////////////////////////////////////////////////////
   #ifdef SU_3D_API_D3D9
      #define SuSqrt(x) sqrt(x)
   #else
      #define SuSqrt(x) sqrt( abs(x) )
   #endif

   ////////////////////////////////////////////////////////////////////////////
   // SuAtan2(x,y)
   //   Atan2 function which duplicates D3D9's Atan2 behavior atan2(0,0) == 0
   //    instead of atan2(0,0) == Nan
   ////////////////////////////////////////////////////////////////////////////
   float SuAtan2( float x, float y )
   {
      float ret = atan2(x,y);

#if defined(SU_3D_API_D3D10) || defined(SU_3D_API_D3D11)
      [flatten] if( x == 0 && y == 0 )
      {
         return 0;
      }
#endif

      return ret;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert degrees to radians
   ////////////////////////////////////////////////////////////////////////////
   float SuDegreeToRad( float r )
   {
      return r*(SU_PI/180.0f);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert radians to radians
   ////////////////////////////////////////////////////////////////////////////
   float SuRadToDegree( float r )
   {
      return r*(180.0f/SU_PI);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute the reflection vector given a view vector and normal.
   ////////////////////////////////////////////////////////////////////////////
   float3 SuReflect (float3 viewVec, float3 normal)
   {
      return normalize (2*dot (viewVec, normal)*normal - viewVec);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute the reflection vector given a view vector, normal, and
   // view dot normal
   ////////////////////////////////////////////////////////////////////////////
   float3 SuReflect (float3 viewVec, float3 normal, float nDotV)
   {
      return normalize ((2 * nDotV * normal) - viewVec);
   }

   /////////////////////////////////////////////////////////////////////////////
   // Computes an approximated fresnel term == [((1.0f - N.V)^5) * 0.95f] + 0.05f
   /////////////////////////////////////////////////////////////////////////////
   float SuComputeFresnelApprox (float3 normalVec, float3 viewVec)
   {
      // (1-N.V)^4
      float NdotV5 = pow (1.0f - SuDot3Clamp (normalVec, viewVec), 4.0f);

      // scale and bias to fit to real fresnel curve
      return (NdotV5 * 0.95f) + 0.05f;
   }

   float SuComputeFresnelApprox (float NdotV)
   {
      // (1-N.V)^4
      float NdotV5 = pow (1.0f - NdotV, 4.0f);

      // scale and bias to fit to real fresnel curve
      return (NdotV5 * 0.95f) + 0.05f;
      
   }
   /////////////////////////////////////////////////////////////////////////////
   // Schlick's approximation of Fresnel
   /////////////////////////////////////////////////////////////////////////////
   float SchlickFresnel( float cosTheta, float R )
   {
      return ( R + SuPow( 1.0 - cosTheta, 5.0 ) * ( 1.0 - R ) );
   }

   ///////////////////////////////////////////////////////////////////////////////////
   // Struck's Fresnel Term (good for approximating subsurface scattering in skin)
   // I'm not sure of the original reference for this technique, see John Isidoro's 
   // skin rendering smmary for discussion.
   //
   // fSoftnessMin and fSoftnessMax are constants controlling the range of luminance 
   // values the fresnel term is applied to.
   ///////////////////////////////////////////////////////////////////////////////////
   float SuStruckFresnel ( float fLuminance, float fSoftnessMin, float fSoftnessMax, float3 vNormal, float3 vView )
   {
      float fAttenuation = max(0,(fLuminance - fSoftnessMin))/(fSoftnessMax - fSoftnessMin);
      float fNV = abs( dot(vNormal, vView) );
      return (1-fNV)*fAttenuation;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute transmission direction T from incident direction I, normal N,
   // going from medium with refractive index n1 to medium with refractive
   // index n2, with refraction governed by Snell's law:
   //               n1*sin(theta1) = n2*sin(theta2).
   // If there is total internal reflection, return 0, else set T and
   // return 1. All vectors unit.
   // From: http://research.microsoft.com/~hollasch/cgindex/render/refraction.txt
   ////////////////////////////////////////////////////////////////////////////
   float3 SuTransmissionDirection (float fromIR, float toIR, 
                                   float3 incoming, float3 normal)
   {
      float eta = fromIR/toIR; // relative index of refraction
      float c1 = -dot (incoming, normal); // cos(theta1)
      float cs2 = 1.-eta*eta*(1.-c1*c1); // cos^2(theta2)
      float3 v = (eta*incoming + (eta*c1-sqrt(cs2))*normal);
      if (cs2 < 0.) v = 0; // total internal reflection
      return v;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute the full Fresnel terms going from one index of refraction to
   // another. Returns both the transmitted term and the reflected terms.
   ////////////////////////////////////////////////////////////////////////////
   float3 SuFullFresnel (float fromIR, float toIR,  float3 incoming,
                         float3 normal, out float reflect, out float transmit)
   { 
      float3 Tvec = SuTransmissionDirection (fromIR, toIR, incoming, normal);
      float NdotOmega = dot (normal, incoming);
      float NdotT = dot (normal, Tvec);
      float rPar = (toIR*NdotOmega + fromIR*NdotT)/
                   (toIR*NdotOmega - fromIR*NdotT);
      float rPerp = (fromIR*NdotOmega + toIR*NdotT)/
                    (fromIR*NdotOmega - toIR*NdotT);
      reflect = 0.5 * (rPar*rPar + rPerp*rPerp);
      float eta = fromIR/toIR; // relative index of refraction
      transmit = (1.0 - reflect)*(eta*eta);
      return Tvec;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute the diffuse falloff hack defined by Mr. Alex Vlachos.  This 
   // causes N.L to prematurely falloff, thus masking the hard edge that would 
   // otherwise be visible.
   ////////////////////////////////////////////////////////////////////////////
   float SuComputeDiffuseHack (float diffuseNdotL)
   {
      return saturate ((diffuseNdotL * (5.0f/4.0f)) - (1.0f/4.0f));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute the diffuse falloff hack defined by Mr. Alex Vlachos.  This 
   // causes N.L to prematurely falloff, thus masking the hard edge that would 
   // otherwise be visible.
   // diffuseBumpNdotL is N.L with N coming from bump map
   // diffuseNdotL is N.L with N coming from geometry (lightVec.z in tangent space)
   ////////////////////////////////////////////////////////////////////////////
   float SuComputeDiffuseBumpHack (float diffuseNdotL, float diffuseBumpNdotL)
   {
      float hack = SuComputeDiffuseHack (diffuseBumpNdotL);
      hack *=  1.0f - (pow (1.0f - SuComputeDiffuseHack (diffuseNdotL), 8.0f));

      return saturate (hack);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Computes R.L^k where k = (exponent * (max - min)) + min
   // This assumes reflectionVec and lightVec are normalized vectors
   ////////////////////////////////////////////////////////////////////////////
   float SuComputeSpecular (float3 reflectionVec, float3 lightVec, float exponent, float min, float max)
   {
      float scale = max - min;
      float k = (exponent * scale) + min;
      float RL = SuDot3Clamp(reflectionVec, lightVec);

      return pow (RL, k);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Turn a color into a grayscale value.
   ////////////////////////////////////////////////////////////////////////////
   float SuMakeWeightedGrayScale (float3 color)
   {
      return dot (color, float3(0.30f, 0.59f, 0.11f));
   }

   float SuMakeGrayScale (float3 color)
   {
      return dot (color, float3(0.333f, 0.333f, 0.333f));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Pack a vector into a color 
   ////////////////////////////////////////////////////////////////////////////
   float4 SuConvertVectorToColor (float4 vec)
   {
      return ((vec * 0.5f) + 0.5f);
   }

   float3 SuConvertVectorToColor (float3 vec)
   {
      return ((vec * 0.5f) + 0.5f);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert from RGB color space into YUV color space
   ////////////////////////////////////////////////////////////////////////////
   float3 SuRGBToYUV( float3 color )
   {
      // http://en.wikipedia.org/wiki/YUV
      float Y = dot( color.xyz, float3( 0.299, 0.587, 0.114) ); // Luminance
      float U = 0.436 * ( color.b - Y ) / ( 1 - 0.114 );
      float V = 0.615 * ( color.r - Y ) / ( 1 - 0.299 );
      
      return float3( Y,U,V );
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert from YUV color space into RGB color space
   ////////////////////////////////////////////////////////////////////////////
   float3 SuYUVToRGB( float3 color )
   {
      return mul( float3x3( 1,  0,        1.3983,
                            1, -0.39465, -0.58060,
                            1,  2.03211,  0 ), color );                         
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert HDR floating point RGB values into RGBE 
   ////////////////////////////////////////////////////////////////////////////
   float4 SuEncodeRGBE (float3 rgb)
   {
	   float4 vEncoded;

       // Determine the largest color component
	   float maxComponent = max( max(rgb.r, rgb.g), rgb.b );
	   
	   // Round to the nearest integer exponent
	   float fExp = ceil( log2(maxComponent) );

       // Divide the components by the shared exponent
	   vEncoded.rgb = rgb / exp2(fExp);
	   
	   // Store the shared exponent in the alpha channel
	   vEncoded.a = (fExp + 128) / 255;

	   return vEncoded;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert RGBE8 texels into HDR floating point RGB values
   ////////////////////////////////////////////////////////////////////////////
   float3 SuDecodeRGBE (float4 rgbe)
   {
	   float3 vDecoded;

      // Retrieve the shared exponent
	   float fExp = rgbe.a * 255 - 128;
	   
	   // Multiply through the color components
	   vDecoded = rgbe.rgb * exp2(fExp);
	   
	   return vDecoded;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Bilinear sample an RGBE8 texture
   ////////////////////////////////////////////////////////////////////////////
   float3 SuBilinearFilterRGBE ( sampler tLightMap, float2 vTexCoord, float2 vTexelSize, float2 vTextureSize )
   {
      static const float4  mTexelOffsets[4] = { { 0.0,  0.0, 0, 0},
                                                { 1.0,  0.0, 0, 0},
                                                { 0.0,  1.0, 0, 0},
                                                { 1.0,  1.0, 0, 0} };

      float2 vTexCoordsTexel = vTexCoord * vTextureSize;

      //find min of change in u and v across quad
      float2 vDx = ddx( vTexCoordsTexel );
      float2 vDy = ddy( vTexCoordsTexel );

      float2 vDCoords;
      vDCoords = vDx * vDx;
      vDCoords += vDy * vDy;  //compute du and dv magnitude across quad

      //standard mipmapping uses max here
	   float fMaxTexCoordDelta = max( vDCoords.x, vDCoords.y );

      //compute mip level  (* 0.5 is effectively computing a square root before the )
      float fMipLevel = 0.5 * log2( fMaxTexCoordDelta );
	   fMipLevel = max( fMipLevel, 0 );

      float fMipLevelInt;
      float fMipLevelFrac;

      fMipLevelFrac = modf( fMipLevel, fMipLevelInt );

      float4 vNewCoord = float4( vTexCoord.xy, fMipLevelInt, fMipLevelInt );

      //texelOffset in texture coordinates for this miplevel	
      //float4 vFullTexelOffset = float4( vTexelSize * pow(2,fMipLevelInt) , 0.0, 0.0 );
	   float4 vFullTexelOffset = float4( ldexp( vTexelSize, fMipLevelInt ), 0.0, 0.0 );

      // Texture size for this miplevel
	   //mipLevelSize = g_vShadowMapSize / (2^mipLevelInt);
	   float2 vMipLevelSize = ldexp( vTextureSize, -fMipLevelInt );

      vNewCoord.xy -= (1.0/vMipLevelSize)*0.5;
      

      // Fractional component of texel offset for bilinear blending
	   float2 vFrac = frac( vNewCoord.xy * vMipLevelSize.xy );

      //return SuDecodeRGBE( tex2D( tLightMap, vTexCoord ) );
      

      //sample nearest 2x2 quad
      float3 cColor0 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord ) );
      float3 cColor1 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[1] * vFullTexelOffset ) ) );
      float3 cColor2 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[2] * vFullTexelOffset ) ) );
      float3 cColor3 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[3] * vFullTexelOffset ) ) );

      //bilinear interpolation weights
	   float4 vBilinearWeights =  float4( 1.0-vFrac.x, vFrac.x, 1.0-vFrac.x, vFrac.x );
	   vBilinearWeights *= float4( 1.0-vFrac.y, 1.0-vFrac.y, vFrac.y, vFrac.y );

      return ( cColor0*vBilinearWeights.x + cColor1*vBilinearWeights.y + cColor2*vBilinearWeights.z + cColor3*vBilinearWeights.w );
   }

   ////////////////////////////////////////////////////////////////////////////
   // Trilinear sample an RGBE8 texture
   ////////////////////////////////////////////////////////////////////////////
   float3 SuTrilinearFilterRGBE ( sampler tLightMap, float2 vTexCoord, float2 vTexelSize, float2 vTextureSize )
   {
      
      static const float4  mTexelOffsets[4] = { { 0.0,  0.0, 0, 0},
                                                { 1.0,  0.0, 0, 0},
                                                { 0.0,  1.0, 0, 0},
                                                { 1.0,  1.0, 0, 0} };

      float2 vTexCoordsTexel = vTexCoord * vTextureSize;

      //find min of change in u and v across quad
      float2 vDx = ddx( vTexCoordsTexel );
      float2 vDy = ddy( vTexCoordsTexel );

      float2 vCoords;
      vCoords = vDx * vDx;
      vCoords += vDy * vDy;  //compute du and dv magnitude across quad

      //standard mipmapping uses max here
	   float fMaxTexCoordDelta = max( vCoords.x, vCoords.y );

      //compute mip level  (* 0.5 is effectively computing a square root before the )
      float fMipLevel = 0.5 * log2( fMaxTexCoordDelta );
	   fMipLevel = max( fMipLevel, 0 );

      float fMipLevelInt;
      float fMipLevelFrac;

      fMipLevelFrac = modf( fMipLevel, fMipLevelInt );

      float4 vNewCoord = float4( vTexCoord.xy, fMipLevelInt, fMipLevelInt );

      //texelOffset in texture coordinates for this miplevel	
	   //fullTexelOffset = g_vFullTexelOffset * (2^mipLevelInt);
	   float4 vFullTexelOffset = float4( ldexp( vTexelSize, fMipLevelInt ), 0.0, 0.0 );

      // Texture size for this miplevel
	   //mipLevelSize = g_vShadowMapSize / (2^mipLevelInt);
	   float2 vMipLevelSize = ldexp( vTextureSize, -fMipLevelInt );
      vNewCoord.xy -= (1.0/vMipLevelSize)*0.5;

      //bias for this miplevel (could possibly be pre-evaluated in the shadow map)
	   // double bias each layer down the mipchain
	   //mipLevelBias = ldexp( g_fDistBias, fMipLevelInt );

      // Fractional component of texel offset for bilinear blending
	   float2 vFrac = frac( vNewCoord.xy * vMipLevelSize.xy );

      //sample nearest 2x2 quad
      float3 cColor0 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord ) );
      float3 cColor1 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[1] * vFullTexelOffset ) ) );
      float3 cColor2 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[2] * vFullTexelOffset ) ) );
      float3 cColor3 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[3] * vFullTexelOffset ) ) );

      //bilinear interpolation weights
	   float4 vBilinearWeights =  float4( 1.0-vFrac.x, vFrac.x, 1.0-vFrac.x, vFrac.x );
	   vBilinearWeights *= float4( 1.0-vFrac.y, 1.0-vFrac.y, vFrac.y, vFrac.y );

      float3 cSample = ( 1.0 - fMipLevelFrac) * ( cColor0*vBilinearWeights.x + cColor1*vBilinearWeights.y + cColor2*vBilinearWeights.z + cColor3*vBilinearWeights.w );

      // set next mip level
      vNewCoord.zw += 1.0;

      //texelOffset in texture coordinates for this miplevel	
      vFullTexelOffset = vFullTexelOffset * 2.0f;

      // Texture size for this miplevel
	   vMipLevelSize = vMipLevelSize * 0.5f;
      vNewCoord.xy -= (1.0/vMipLevelSize)*0.25;

      // Fractional component of texel offset for bilinear blending
	   vFrac = frac( vNewCoord.xy * vMipLevelSize.xy );

      //bilinear interpolation weights
      vBilinearWeights =  float4( 1.0-vFrac.x, vFrac.x, 1.0-vFrac.x, vFrac.x );
	   vBilinearWeights *= float4( 1.0-vFrac.y, 1.0-vFrac.y, vFrac.y, vFrac.y );

      //sample nearest 2x2 quad
      cColor0 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord ) );
      cColor1 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[1] * vFullTexelOffset ) ) );
      cColor2 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[2] * vFullTexelOffset ) ) );
      cColor3 = SuDecodeRGBE( tex2Dlod( tLightMap, vNewCoord + ( mTexelOffsets[3] * vFullTexelOffset ) ) );

      cSample += fMipLevelFrac * ( cColor0*vBilinearWeights.x + cColor1*vBilinearWeights.y + cColor2*vBilinearWeights.z + cColor3*vBilinearWeights.w );

      return cSample;
   }


   ////////////////////////////////////////////////////////////////////////////
   // Distributes an integer range across four color channels [0, MAXINT] -> <[0,1], [0,1], [0,1]>
   ////////////////////////////////////////////////////////////////////////////
   float3 SuEncodeUIntAsColor (int i)
   {
  
      float3 cOut = 0;
      i = max(i, 0); // this won't encode signed values

      cOut.r = saturate( (i % 256) / 255.0f );
      cOut.g = saturate( ((i / 256) % 256) / 255.0f );
      cOut.b = saturate( ((i / 65536) % 256) / 255.0f );

      return cOut;
   }

   int SuDecodeUIntAsColor (float3 color)
   {
      return dot(color, float3(255.0f, 65535.0f, 16777215.0f));
   }


   ////////////////////////////////////////////////////////////////////////////
   // Un Pack a vector from a color 
   ////////////////////////////////////////////////////////////////////////////
   float4 SuConvertColorToVector (float4 color)
   {
      return ((color * 2.0f) - 1.0f);
   }

   float3 SuConvertColorToVector (float3 color)
   {
      return ((color * 2.0f) - 1.0f);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Get the shadow term for a given number of lights. The number of lights
   // term determines how close to the "true" ambient term to return. For
   // a single light you only get the ambient term, for two lights you get
   // half the real light, three lights you get two thirds of the full light.
   ////////////////////////////////////////////////////////////////////////////
   float SuComputeShadowDimFactor (float3 ambientLight, float3 combinedLight,
                                   int numLights)
   {
      return lerp ((SuMakeGrayScale(ambientLight) / SuMakeGrayScale(combinedLight)), 1.0, (((float)numLights-1.0f)/numLights));
   }

   ////////////////////////////////////////////////////////////////////////////
   // As with the above function this one returns the ambient term, but is 
   // more optimized since we know there is no lerp involved.
   ////////////////////////////////////////////////////////////////////////////
   float SuComputeShadowDimFactorOneLight (float3 ambientLight,
                                           float3 combinedLight)
   {
      return (SuMakeGrayScale(ambientLight) / SuMakeGrayScale(combinedLight));
   }

   float SuGetLuminance (float3 color)
   {
      return (dot (color, float3(0.3, 0.59, 0.11)));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute luminance value from a given RGB color using formula from
   // Reinhard paper (http://www.cs.ucf.edu/~reinhard/papers/jgt_reinhard.pdf)
   ////////////////////////////////////////////////////////////////////////////
   float SuGetReinhardLuminance( float3 cRGBValue )
   {
      return dot( cRGBValue, float3(0.27, 0.67, 0.06));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute Z and scale ATI2N bump maps
   ////////////////////////////////////////////////////////////////////////////
      
   
   ////////////////////////////////////////////////////////////////////////////
   // Compute Z and scale ATI2N bump maps
   ////////////////////////////////////////////////////////////////////////////
   float3 SuComputeNormalATI2Nxy(float2 v, float xyscale)
   {
      v = v*2.0-1.0;
#ifdef SU_3D_API_D3D9
      // We used to use a dot product here, but the D3D9 Dec. SDK HLSL compiler screws it all up...
      float3 r = float3( v, SuSqrt( 1.0 - v.x*v.x - v.y*v.y ) );
#else
      float3 r = float3( v, SuSqrt( 1.0 - dot(v, v) ) );
#endif
      r.xy *= xyscale;
      return normalize(r);
   }

   float3 SuComputeNormalATI2N(float2 v, float zscale)
   {  
      v = v*2.0-1.0;
#ifdef SU_3D_API_D3D9
      // We used to use a dot product here, but the D3D9 Dec. SDK HLSL compiler screws it all up...
      float3 r = float3( v, SuSqrt( 1.0 - v.x*v.x - v.y*v.y ) );
#else
      float3 r = float3( v, SuSqrt( 1.0 - dot(v, v) ) );
#endif
      r.z *= zscale;
      return normalize(r);
   }

   float3 SuComputeNormalATI2N(float2 v)
   {  
      v = v * 2.0 - float2( 1.0, 1.0 );
#ifdef SU_3D_API_D3D9
      // We used to use a dot product here, but the D3D9 Dec. SDK HLSL compiler screws it all up...
      float3 r = float3( v, SuSqrt( 1.0 - v.x*v.x - v.y*v.y ) );
#else
      float3 r = float3( v, SuSqrt( 1.0 - dot(v, v) ) );
#endif
      return r;
   }

   // Decodes a dec3n vertex shader input element and brings it into [-1, 1] range.
   float3 SuDecodeDec3N( float3 vVal )
   {
#ifdef SU_3D_API_D3D9
      return vVal;      // D3D9
#else
      return 2.0 * vVal - 1.0;   // D3D10 & D3D11
#endif
   }

   //==========================================================//
   // Convert cartesian coordinates into spherical coordinates //
   // returns <theta, phi>                                     //
   //==========================================================//
   float2 SuCartesian2Spherical (float3 cartesian)
   {
      float theta;
      float phi;

      theta = acos(cartesian.z);

      float s = cartesian.x*cartesian.x + cartesian.y*cartesian.y;
      if (s <= 0.0)
      {
         phi = 0.0;
      }
      else
      {
         s = sqrt(s);
    
         if (cartesian.x >= 0.0)
         {
            phi = asin(cartesian.y/s);
         }
         else
         {
            phi = 3.14159265359 - asin(cartesian.y/s);
         }
      }

      return float2(theta, phi);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Decode the Sushi packing of 1010102 "HDR"
   ////////////////////////////////////////////////////////////////////////////
   float3 SuDecode1010102HDR (float4 hdrSample)
   {
      return hdrSample.rgb * 4.0 * (hdrSample.a * 3.0 + 1.0);
   }
   
   ////////////////////////////////////////////////////////////////////////////
   // Decode the Sushi packing of 1010102 "HDR"
   ////////////////////////////////////////////////////////////////////////////
   float3 SuDecode1010102HDRDeGamma (float4 hdrSample)
   {
      return pow(hdrSample.rgb * 4.0 * (hdrSample.a * 3.0 + 1.0), 1/2.2);
   }

   // Similar interface to smoothstep, but does a straight linear function
   // between min and max
   float4 SuLerpStep (float minV, float maxV, float4 value)
   {
      return saturate((value - minV)/(maxV - minV));
   }   

   // Similar interface to smoothstep, but does a straight linear function
   // between min and max
   float3 SuLerpStep (float minV, float maxV, float3 value)
   {
      return saturate((value - minV)/(maxV - minV));
   }   

   // Similar interface to smoothstep, but does a straight linear function
   // between min and max
   float2 SuLerpStep (float minV, float maxV, float2 value)
   {
      return saturate((value - minV)/(maxV - minV));
   }   

   // Similar interface to smoothstep, but does a straight linear function
   // between min and max
   float SuLerpStep (float minV, float maxV, float value)
   {
      return saturate((value - minV)/(maxV - minV));
   }   

   ////////////////////////////////////////////////////////////////////////////
   // Computes the area of intersection of two spherical caps.
   // r0 : radius of spherical cap 0 (radians)
   // r1 : radius of spherical cap 1 (radians)
   // d  : distance between cetroids of cap 0 and cap 1 (radians)
   ////////////////////////////////////////////////////////////////////////////
   float SuSphericalCapIntersectionArea ( float r0, float r1, float d )
   {
      float fArea;

      if ( min(r0, r1) <= max(r0, r1) - d )
      {
         // One cap in completely inside the other
         fArea = 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }
      else if ( r0 + r1 <= d )
      {
         // No intersection exists
         fArea = 0;
      }
      else
      {
         fArea = 2.0 * acos( (-cos(d) + cos(r0)*cos(r1)) / (sin(r0)*sin(r1)) ) -
                 2.0 * acos( (cos(r1) - cos(d)*cos(r0)) / (sin(d)*sin(r0)) ) * cos(r0) - 
                 SU_2PI * cos(r1) +
                 2.0 * cos(r1) * acos( (-cos(r0) + cos(d)*cos(r1)) / (sin(d)*sin(r1)) );
        /*
         fArea = 2.0 * ( -acos( cos(d) * csc(r0) * csc(r1) - cot(r0) * cot(r1) ) -
	              acos( cos(r1) * csc(d) * csc(r0) - cot(d) * cot(r0) ) * cos(r0) -
	              acos( cos(r0) * csc(d) * csc(r1) - cot(d) * cot(r1) ) * cos(r1) + SU_PI);
        */
      }

      return fArea;
   }

   float SuSphericalCapIntersectionAreaFast ( float r0, float r1, float d )
   {
      float fArea;

      if ( d  <= max(r0, r1) - min(r0, r1) )
      {
         // One cap in completely inside the other
         fArea = 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }
      else if ( d >= r0 + r1 )
      {
         // No intersection exists
         fArea = 0;
      }
      else
      {
         float b = abs(r0 - r1);
         fArea = (1.0 - saturate((d - b) / (r0 + r1 - b))) * (6.283185308 - 6.283185308 * cos( min(r0,r1) ));
      }

      return fArea;
   }

   float SuSphericalCapIntersectionAreaFastNoDyn ( float r0, float r1, float d )
   {
      float b = abs(r0 - r1);
      return (1.0 - saturate((d - b) / (r0 + r1 - b))) * (6.283185308 - 6.283185308 * cos( min(r0,r1) ));
   }

   float SuSphericalCapIntersectionAreaFast2 ( float r0, float r1, float d )
   {
      float fArea;

      if ( d <= abs(r0 - r1) )
      {
         // One cap in completely inside the other
         fArea = 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }
      else if ( d >= r0 + r1 )
      {
         // No intersection exists
         fArea = 0;
      }
      else
      {
         float b = abs(r0 - r1);
         fArea = smoothstep(0.0, 1.0, 1.0 - saturate((d - b) / (r0 + r1 - b)));
         fArea *= 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }

      return fArea;
   }

   float SuSphericalCapIntersectionAreaFast3 ( float r0, float r1, float d )
   {
      float fArea;

      if ( d <= abs(r0 - r1) )
      {
         // One cap in completely inside the other
         fArea = 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }
      else if ( d >= r0 + r1 )
      {
         // No intersection exists
         fArea = 0;
      }
      else
      {
         float b = abs(r0 - r1);
         fArea = SuLerpStep(0.0, 1.0, 1.0 - saturate((d - b) / (r0 + r1 - b)));
         fArea *= 6.283185308 - 6.283185308 * cos( min(r0,r1) );
      }

      return fArea;
   }

   float SuSphericalCapIntersectionAreaFast2NoDyn ( float r0, float r1, float d )
   {
      float b = abs(r0 - r1);
      return smoothstep(0.0, 1.0, 1.0 - ((d - b) / (r0 + r1 - b))) * (6.283185308 - 6.283185308 * cos( min(r0,r1) ));
   }

   /////////////////////////////////////////////////////////////////////////////
   // Note: this assumes sphere space coordinates: the center of the sphere is at (0,0,0)
   // fSphereRadiusSquared = radius squared
   // vRayOrigin = ray original (point)
   // vRayDirection = ray direction (vector)
   /////////////////////////////////////////////////////////////////////////////

   float SuSphereIntersect ( float fSphereRadiusSquared, float3 vRayOrigin, float3 vRayDirection )
   {
      float3 v = float3( 0, 0, 0 ) - vRayOrigin;
      float b = dot( v, vRayDirection );
      float disc = ( b * b ) - dot( v, v ) + fSphereRadiusSquared;
      disc = SuSqrt( disc );
      float t2 = b + disc;
      float t1 = b - disc;
      return max( t1, t2 );
   } 

   /////////////////////////////////////////////////////////////////////////////
   // Converts a Z-buffer value to a camera-space distance
   /////////////////////////////////////////////////////////////////////////////
   float SuNDCDepthToCameraDepth( float fNDCDepth, float4 vCamParams )
   {
      return (-vCamParams.z * vCamParams.w) / ( fNDCDepth * (vCamParams.w - vCamParams.z) - vCamParams.w );
   }


   /////////////////////////////////////////////////////////////////////////////
   float SuBarycentricLerp( float f0, float f1, float f2, float3 vBarycentrics )
   {
      return f0*vBarycentrics.x + f1*vBarycentrics.y + f2*vBarycentrics.z;
   }

   /////////////////////////////////////////////////////////////////////////////
   float2 SuBarycentricLerp( float2 f0, float2 f1, float2 f2, float3 vBarycentrics )
   {
      return f0.xy*vBarycentrics.x + f1.xy*vBarycentrics.y + f2.xy*vBarycentrics.z;
   }
   
   /////////////////////////////////////////////////////////////////////////////   
   float3 SuBarycentricLerp( float3 f0, float3 f1, float3 f2, float3 vBarycentrics )
   {
      return f0.xyz*vBarycentrics.x + f1.xyz*vBarycentrics.y + f2.xyz*vBarycentrics.z;
   }

   /////////////////////////////////////////////////////////////////////////////
   float4 SuBarycentricLerp( float4 f0, float4 f1, float4 f2, float3 vBarycentrics )
   {
      return f0.xyzw*vBarycentrics.x + f1.xyzw*vBarycentrics.y + f2.xyzw*vBarycentrics.z;
   }

EndHLSL

//=============================================================================
// Matrix math functions
//=============================================================================
StartHLSL MathMatrix

   ////////////////////////////////////////////////////////////////////////////
   // Returns a full 4x4 identity matrix
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuMakeIdentityMatrix (void)
   {
      float4x4 mat = { 1.0f, 0.0f, 0.0f, 0.0f,
                       0.0f, 1.0f, 0.0f, 0.0f,
                       0.0f, 0.0f, 1.0f, 0.0f,
                       0.0f, 0.0f, 0.0f, 1.0f };
      return mat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Create a translation matrix given the x, y, and z translation components
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuMakeTranslationMatrix (float x, float y, float z)
   {
      float4x4 mat = SuMakeIdentityMatrix ();
      mat._m03 = x;
      mat._m13 = y;
      mat._m23 = z;
      return mat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Create a scale matrix given the x, y, and z scaling components
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuMakeScaleMatrix (float x, float y, float z)
   {
      float4x4 mat = SuMakeIdentityMatrix ();
      mat._m00 = x;
      mat._m11 = y;
      mat._m22 = z;
      return mat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Create a rotation matrix that rotates a vector called "from" into another
   // vector called "to".
   // source: http://www.cs.lth.se/home/Tomas_Akenine_Moller/code/fromtorot.txt
   ////////////////////////////////////////////////////////////////////////////
   float3x3 SuMakeFromToRotationMatrix ( float3 vFrom, float3 vTo )
   {
      float3x3 mResult;
      float3 vV = cross( vFrom, vTo );
      float fE = dot( vFrom, vTo );
      float fF = abs( fE );

      if ( fF > 0.999 ) // vFrom and vTo almost parallel
      {
         float3 vX = abs( vFrom );

         if ( vX.x < vX.y )
         {
            if ( vX.x < vX.z )
            {
               vX = float3( 1.0, 0.0, 0.0 );
            }
            else
            {
               vX = float3( 0.0, 0.0, 1.0 );
            }
         }
         else
         {
            if ( vX.y < vX.z )
            {
               vX = float3( 0.0, 1.0, 0.0 );
            }
            else
            {
               vX = float3( 0.0, 0.0, 1.0 );
            }
         }

         float3 vU = vX - vFrom;
         float3 vV = vX - vTo;

         float fC1 = 2.0 / dot( vU, vU );
         float fC2 = 2.0 / dot( vV, vV );
         float fC3 = fC1 * fC2 * dot( vU, vV );

         for ( int i = 0; i < 3; i++ )
         {
            for ( int j = 0; j < 3; j++ )
            {
               mResult[j][i] = - fC1 * vU[i] * vU[j] 
                               - fC2 * vV[i] * vV[j]
                               + fC3 * vV[i] * vU[j];
            }

            mResult[i][i] += 1.0;
         }

      }
      else
      {
         float fH = 1.0 / (1.0 + fE);

         mResult[0][0] = fE + fH * vV.x * vV.x;
         mResult[1][0] = fH * vV.x * vV.y + vV.z;
         mResult[2][0] = fH * vV.x * vV.z - vV.y;
                   
         mResult[0][1] = fH * vV.x * vV.y - vV.z;
         mResult[1][1] = fE + fH * vV.y * vV.y;
         mResult[2][1] = fH * vV.y * vV.z + vV.x;
                   
         mResult[0][2] = fH * vV.x * vV.z + vV.y;
         mResult[1][2] = fH * vV.y * vV.z - vV.x;
         mResult[2][2] = fE + fH * vV.z * vV.z;
      }

      return mResult;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Same as above, but skips the test to see if the vectors are parallel
   ////////////////////////////////////////////////////////////////////////////
   float3x3 SuMakeFromToRotationMatrixFast ( float3 vFrom, float3 vTo )
   {
      float3x3 mResult;
      float3 vV = cross( vFrom, vTo );
      float fE = dot( vFrom, vTo );
      float fH = 1.0 / (1.0 + fE);

      mResult[0][0] = fE + fH * vV.x * vV.x;
      mResult[1][0] = fH * vV.x * vV.y + vV.z;
      mResult[2][0] = fH * vV.x * vV.z - vV.y;
                
      mResult[0][1] = fH * vV.x * vV.y - vV.z;
      mResult[1][1] = fE + fH * vV.y * vV.y;
      mResult[2][1] = fH * vV.y * vV.z + vV.x;
                
      mResult[0][2] = fH * vV.x * vV.z + vV.y;
      mResult[1][2] = fH * vV.y * vV.z - vV.x;
      mResult[2][2] = fE + fH * vV.z * vV.z;


      return mResult;
   }

   ////////////////////////////////////////////////////////////////////////////
   // 
   // Calculate the rotation matrix that corresponds to the rotation specified
   // by an arbitrary axis whose components determine the direction of the 
   // axis and whose length indicates the amount of rotation (this is what 
   // physicists call the infinitesimal angular displacement)
   //
   // Source: Robot Manipulators: Mathematics, Programming and Control
   //         by Richard Paul, pg. 28
   //
   //
   //  This is the matrix m:
   //
   // WARNING: vAxis is assumed to be unit length!
   // 
   // --                                                                 --
   //| kx*kx*vers0 + cos0     ky*kx*vers0 - kz*sin0  kz*kx*vers0 + ky*sin0 |
   //| kx*ky*vers0 + kz*sin0  ky*ky*vers0 + kz*cos0  kz*ky*vers0 - kx*sin0 |
   //| kx*kz*vers0 - ky*sin0  ky*kz*vers0 + kx*sin0  kz*kz*vers0 + cos0    |
   // --                                                                 --
   ////////////////////////////////////////////////////////////////////////////
   float3x3 SuArbitraryAxisToMatrix (float3 vAxis, float fRadians )
   {
      float3x3 mTransform;

      if ( abs(fRadians) < 0.001 )
      {
         mTransform = SuMakeIdentityMatrix();
      }
      else
      {
         // Calculate angles
         float fSin0 = sin( fRadians );
         float fCos0 = cos( fRadians );
         float fVers0 = 1.0 - fCos0;

         // Calculate commonly used values
         float3 vVers0 = vAxis * fVers0;
         float3 vSin0 = vAxis * fSin0;

         // Calculate matrix elements (see above descriptions) //
         mTransform[0] = vAxis * vVers0.xxx + float3(fCos0, -vSin0.z, vSin0.y);
         mTransform[1] = vAxis * vVers0.yyy + float3(vSin0.z, fCos0, -vSin0.x);
         mTransform[2] = vAxis * vVers0.zzz + float3(-vSin0.y, vSin0.x, fCos0);
      }
      
      return mTransform;
   }


   ////////////////////////////////////////////////////////////////////////////
   // Multiply two 4x4 matrices.
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuMult44x44 (float4x4 m1, float4x4 m2)
   {
      return mul (m1, m2);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply a 4x4 matrix with a 3 space vector
   ////////////////////////////////////////////////////////////////////////////
   float4 SuMult44x41 (float4x4 mat, float4 vec)
   {
      return mul (mat,vec);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply a 4x4 matrix with a 3 space vector
   ////////////////////////////////////////////////////////////////////////////
   float3 SuMult44x31 (float4x4 mat, float3 vec)
   {
      return mul (mat, float4(vec, 1));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply the 3x3 portion of the 4x4 matrix with a 3 space vector
   ////////////////////////////////////////////////////////////////////////////
   float3 SuMult33x31 (float4x4 mat, float3 vec)
   {
      return mul (mat, float4(vec,0));
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply a 3x3 matrix with a 3 space vector
   ////////////////////////////////////////////////////////////////////////////
   float3 SuMult33x31 (float3x3 mat, float3 vec)
   {
      return mul (mat,vec);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply the 3x3 portion of the 4x4 matrix with a 4 space vector
   ////////////////////////////////////////////////////////////////////////////
   float4 SuMult33x41 (float4x4 mat, float4 vec)
   {
      float3 v = mul (mat, float4(vec.xyz,0));
      return float4 (v, 1);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiply a 3x3 matrix with a 4 space vector
   ////////////////////////////////////////////////////////////////////////////
   float4 SuMult33x41 (float3x3 mat, float4 vec)
   {
      float3 v = mul (mat, vec.xyz);
      return float4 (v, 1);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Transpose a matrix.
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuTransposeMatrix (float4x4 mat)
   {
      return transpose (mat);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Cheap(er) invert matrix. Only works for orthonormal matrices with no
   // shearing/scaling.
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuRigidInvertMatrix ( float4x4 inMat )
   {
      // Rotations are just the transpose.
      float4x4 mat = transpose( inMat );

      // Clear shearing terms
      mat[3] = float4(0,0,0,1);

      // Translation is minus the dot of tranlation and rotations
      float4 v = float4( inMat._m03, inMat._m13, inMat._m23, 0 );
      mat._m03 = -dot(v, float4 (inMat._m00, inMat._m01, inMat._m02, 0));
      mat._m13 = -dot(v, float4 (inMat._m10, inMat._m11, inMat._m12, 0));
      mat._m23 = -dot(v, float4 (inMat._m20, inMat._m21, inMat._m22, 0));

      return mat;
   }

EndHLSL

//=============================================================================
// Quaternion math functions
//=============================================================================
StartHLSL MathQuaternion


   ////////////////////////////////////////////////////////////////////////////
   // Convert a quaternion to a matrix.
   ////////////////////////////////////////////////////////////////////////////
   float4x4 SuQuatToMatrix (float4 quat)
   {
/*
      float xx      = quat.x * quat.x;
      float xy      = quat.x * quat.y;
      float xz      = quat.x * quat.z;
      float xw      = quat.x * quat.w;

      float yy      = quat.y * quat.y;
      float yz      = quat.y * quat.z;
      float yw      = quat.y * quat.w;

      float zz      = quat.z * quat.z;
      float zw      = quat.z * quat.w;

      float4x4 mat;
      mat._m00  = 1 - 2 * ( yy + zz );
      mat._m10  =     2 * ( xy - zw );
      mat._m20  =     2 * ( xz + yw );
      mat._m30 = 0.0f;

      mat._m01  =     2 * ( xy + zw );
      mat._m11  = 1 - 2 * ( xx + zz );
      mat._m21  =     2 * ( yz - xw );
      mat._m31 = 0.0f;

      mat._m02  =     2 * ( xz - yw );
      mat._m12  =     2 * ( yz + xw );
      mat._m22 = 1 - 2 * ( xx + yy );
      mat._m32 = 0.0f;

      mat._m03 = 0.0f;
      mat._m13 = 0.0f;
      mat._m23 = 0.0f;
      mat._m33 = 1.0f;
*/

      float x2 = quat.x + quat.x;
      float y2 = quat.y + quat.y;
      float z2 = quat.z + quat.z;

      float xx = quat.x * x2;
      float xy = quat.x * y2;
      float xz = quat.x * z2;
      float yy = quat.y * y2;
      float yz = quat.y * z2;
      float zz = quat.z * z2;
      float wx = quat.w * x2;
      float wy = quat.w * y2;
      float wz = quat.w * z2;

      float4x4 mat;
      mat._m00 = 1.0f - (yy + zz);
      mat._m01 = xy - wz;
      mat._m02 = xz + wy;
      mat._m03 = 0.0f;
               
      mat._m10 = xy + wz;
      mat._m11 = 1.0f - (xx + zz);
      mat._m12 = yz - wx;
      mat._m13 = 0.0f;
               
      mat._m20 = xz - wy;
      mat._m21 = yz + wx;
      mat._m22 = 1.0f - (xx + yy);
      mat._m23 = 0.0f;
               
      mat._m30 = 0.0f;
      mat._m31 = 0.0f;
      mat._m32 = 0.0f;
      mat._m33 = 1.0f;

      return mat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Convert a quaternion/translation pair to a 3x4 transformation matrix
   ////////////////////////////////////////////////////////////////////////////
   float3x4 SuQuatAndTranslationToMatrix ( float4 quat, float3 xlate )
   {
      float x2 = quat.x + quat.x;
      float y2 = quat.y + quat.y;
      float z2 = quat.z + quat.z;

      float xx = quat.x * x2;
      float xy = quat.x * y2;
      float xz = quat.x * z2;
      float yy = quat.y * y2;
      float yz = quat.y * z2;
      float zz = quat.z * z2;
      float wx = quat.w * x2;
      float wy = quat.w * y2;
      float wz = quat.w * z2;

      float3x4 mat;
      mat._m00 = 1.0f - (yy + zz);
      mat._m01 = xy - wz;
      mat._m02 = xz + wy;
      mat._m03 = xlate.x;
               
      mat._m10 = xy + wz;
      mat._m11 = 1.0f - (xx + zz);
      mat._m12 = yz - wx;
      mat._m13 = xlate.y;
               
      mat._m20 = xz - wy;
      mat._m21 = yz + wx;
      mat._m22 = 1.0f - (xx + yy);
      mat._m23 = xlate.z;
               
      return mat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Converts matrix representation of a rotation to a quaternion.
   ////////////////////////////////////////////////////////////////////////////
   float4 SuMatrixToQuat (float4x4 mat)
   {
      float4 quat;
      float fMat[16] = {mat._m00, mat._m10, mat._m20, mat._m30,
                        mat._m01, mat._m11, mat._m21, mat._m31,
                        mat._m02, mat._m12, mat._m22, mat._m32,
                        mat._m03, mat._m13, mat._m23, mat._m33 };

      float tr = mat._m00 + mat._m11 + mat._m22;

      //check the diagonal
      if (tr > 0.0f) 
      {
         float s = sqrt(tr + 1.0f);
         quat.w = s / 2.0f;
         s = 0.5f / s;
         quat.x = (mat._m21 - mat._m12) * s;
         quat.y = (mat._m02 - mat._m20) * s;
         quat.z = (mat._m10 - mat._m01) * s;
      }
      else // Diagonal is negative
      {
         // Reworked from C code to eliminate temp registers.
         if (fMat[5] > fMat[0])
         {
            if (fMat[10] > fMat[5])
            {
               float s = sqrt((fMat[10] - (fMat[0] + fMat[5])) + 1.0f);
               quat.z = s * 0.5;
               if (s != 0.0f)
               {
                  s = 0.5f / s;
               }
               quat.w = (fMat[1] - fMat[4]) * s;
               quat.x = (fMat[8] + fMat[2]) * s;
               quat.y = (fMat[9] + fMat[6]) * s;
            }
            else
            {
               float s = sqrt((fMat[5] - (fMat[10] + fMat[0])) + 1.0f);
               quat.y = s * 0.5f;
               if (s != 0.0f)
               {
                  s = 0.5f / s;
               }
               quat.w = (fMat[8] - fMat[2]) * s;
               quat.z = (fMat[6] + fMat[9]) * s;
               quat.x = (fMat[4] + fMat[1]) * s;
            }
         }
         else
         {
            if (fMat[10] > fMat[0])
            {
               float s = sqrt((fMat[10] - (fMat[0] + fMat[5])) + 1.0f);
               quat.z = s * 0.5f;
               if (s != 0.0f)
               {
                  s = 0.5f / s;
               }
               quat.w = (fMat[1] - fMat[4]) * s;
               quat.x = (fMat[8] + fMat[2]) * s;
               quat.y = (fMat[9] + fMat[6]) * s;
            }
            else
            {
               float s = sqrt((fMat[0] - (fMat[5] + fMat[10])) + 1.0f);
               quat.x = s * 0.5f;
               if (s != 0.0f)
               {
                  s = 0.5f / s;
               }
               quat.w = (fMat[6] - fMat[9]) * s;
               quat.y = (fMat[1] + fMat[4]) * s;
               quat.z = (fMat[2] + fMat[8]) * s;
            }
         }
      }
      return normalize (quat);
   }

   float4 SuMatrixToQuat (float3x3 mat)
   {
      float4x4 mMatrix = { float4( mat[0], 0), float4( mat[1], 0), float4( mat[2], 0), float4(0,0,0,1) };
      return SuMatrixToQuat( mMatrix );
   }

   ////////////////////////////////////////////////////////////////////////////
   // Converts a quaternion into an axis and angle x, y, and z components
   // contain the axis, w contains the angle in degrees.
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuaternionToGlRotation (float4 quat)
   {
      float len = (quat.x*quat.x) + (quat.y*quat.y) + (quat.z*quat.z);
      float4 result;
      if (len > 0.001) 
      {
         result.x = quat.x * (1.0f / len);
         result.y = quat.y * (1.0f / len);
         result.z = quat.z * (1.0f / len);
         result.w = degrees (2.0f * acos(quat.w));
      }
      else
      {
         result.x = 0.0;
         result.y = 0.0;
         result.z = 1.0;
         result.w = 0.0;
      }
      return result;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Creates a quaternion from an axis and angle (in degrees)
   ////////////////////////////////////////////////////////////////////////////
   float4 SuGlRotationToQuaternion (float x, float y, float z, float degrees)
   {
      float rad = radians (degrees);
      float tmpf = sqrt(x*x + y*y + z*z);
      if (tmpf != 0.0f)
      {
         float dist = -sin(rad * 0.5f) / tmpf;
         x *= dist;
         y *= dist;
         z *= dist;
      }
      float4 quat;
      quat.x = x;
      quat.y = y;
      quat.z = z;
      quat.w = cos(rad * 0.5f);
      return quat;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Multiplies two quaternions
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatMul (float4 q1, float4 q2)
   {
      float4 tmpq;
      tmpq.x = (q1.w*q2.x) + (q1.x*q2.w) + (q1.y*q2.z) - (q1.z*q2.y);
      tmpq.y = (q1.w*q2.y) + (q1.y*q2.w) + (q1.z*q2.x) - (q1.x*q2.z);
      tmpq.z = (q1.w*q2.z) + (q1.z*q2.w) + (q1.x*q2.y) - (q1.y*q2.x);
      tmpq.w = (q1.w*q2.w) - (q1.x*q2.x) - (q1.y*q2.y) - (q1.z*q2.z);
      //tmpq = tmpq / (sqrt(tmpq.x*tmpq.x + tmpq.y*tmpq.y + tmpq.z*tmpq.z + tmpq.w*tmpq.w));
      return tmpq;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Calculates natural logarithm of a quaternion
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatLog (float4 q1)
   {
      float length = sqrt(q1.x * q1.x + q1.y * q1.y + q1.z * q1.z);
      length = atan2 (length, q1.w);
      float4 q2;
      q2.x = q1.x * length;
      q2.y = q1.y * length;
      q2.z = q1.z * length;
      q2.w = 0.0f;
      return q2;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Calculates inverse a quaternion
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatInverse (float4 q)
   {
      float tmpf = 1.0f / (q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);
      float4 result;
      result.x = -q.x * tmpf;
      result.y = -q.y * tmpf;
      result.z = -q.z * tmpf;
      result.w =  q.w * tmpf;
      return result;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Calculates exponent of a quaternion
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatExp (float4 q1)
   {
      float len1 = sqrt (q1.x*q1.x + q1.y*q1.y + q1.z*q1.z);
      float len2;
      if (len1 > 0.0) 
         len2 = sin(len1) / len1; 
      else 
         len2 = 1.0;
      float4 q2;
      q2.x = q1.x * len2;
      q2.y = q1.y * len2;
      q2.z = q1.z * len2;
      q2.w = cos(len1);
      return q2;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Smoothly (spherically, shortest path on a quaternion sphere) 
   // interpolates between two UNIT quaternion positions
   //==========================================================================
   // As t goes from 0 to 1, qt goes from p to q.
   // slerp(p,q,t) = (p*sin((1-t)*omega) + q*sin(t*omega)) / sin(omega)
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatSlerp (float4 from, float4 to, float t)
   {
      //Calculate cosine
      float cosom = dot (from, to);

      //Adjust signs (if necessary)
      float4 to1;
      if (cosom < 0.0)
      {
         cosom = -cosom;
         to1[0] = -to.x;
         to1[1] = -to.y;
         to1[2] = -to.z;
         to1[3] = -to.w;
      }
      else
      {
         to1[0] = to.x;
         to1[1] = to.y;
         to1[2] = to.z;
         to1[3] = to.w;
      }

      //Calculate coefficients
      float scale0;
      float scale1;
      if ((1.0f-cosom) > 0.001f)
      {
         //Standard case (slerp)
         float omega = acos(cosom);
         float sinom = sin(omega);
         scale0 = sin((1.0f - t) * omega) / sinom;
         scale1 = sin(t * omega) / sinom;
      }
      else
      {
         //"from" and "to" quaternions are very close
         //... so we can do a linear interpolation
         scale0 = 1.0f - t;
         scale1 = t;
      }

      // calculate final values
      float4 result;
      result.x = (scale0 * from.x) + (scale1 * to1[0]);
      result.y = (scale0 * from.y) + (scale1 * to1[1]);
      result.z = (scale0 * from.z) + (scale1 * to1[2]);
      result.w = (scale0 * from.w) + (scale1 * to1[3]);
      return result;
   }

   ////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatSlerpShortestPath (float4 from, float4 to, float t)
   {
      float4 result;
      if (dot(from, to) < 0.0f)
      {
         float4 tmpFrom = {-from.x, -from.y, -from.z, -from.w};
         result = SuQuatSlerp (tmpFrom, to, t);
      }
      else
      {
         result = SuQuatSlerp (from, to, t);
      }
      return normalize (result);
   }

   ////////////////////////////////////////////////////////////////////////////
   // Cross product of 3 quaternions: result = (q1 X q2 X q3)
   //
   // This is done by creating the matrix:
   //      i   j   k   m
   //      x1  x2  x3  x4
   //      y1  y2  y3  y4
   //      z1  z2  z3  z4
   //      w1  w2  w3  w4
   // and solving for i, j, k, and m. These 4 values compose the resulting
   // Quaternion: result = (i, j, k, m)
   ////////////////////////////////////////////////////////////////////////////
   float4 SuQuatAxBxC (float4 q1, float4 q2, float4 q3)
   {
      float4 result;
      float3x3 det; //Determinant to pass to function

      // result->x
      det[0][0] = q1.y;
      det[0][1] = q1.z;
      det[0][2] = q1.w;

      det[1][0] = q2.y;
      det[1][1] = q2.z;
      det[1][2] = q2.w;

      det[2][0] = q3.y;
      det[2][1] = q3.z;
      det[2][2] = q3.w;

      result.x = determinant(det);

      // result->y
      det[0][0] = q1.x;
      det[0][1] = q1.z;
      det[0][2] = q1.w;
      
      det[1][0] = q2.x;
      det[1][1] = q2.z;
      det[1][2] = q2.w;
      
      det[2][0] = q3.x;
      det[2][1] = q3.z;
      det[2][2] = q3.w;

      result.y = -determinant(det);

      // result->z
      det[0][0] = q1.x;
      det[0][1] = q1.y;
      det[0][2] = q1.w;

      det[1][0] = q2.x;
      det[1][1] = q2.y;
      det[1][2] = q2.w;
      
      det[2][0] = q3.x;
      det[2][1] = q3.y;
      det[2][2] = q3.w;

      result.z = determinant(det);

      // result->w //
      det[0][0] = q1.x;
      det[0][1] = q1.y;
      det[0][2] = q1.z;
      
      det[1][0] = q2.x;
      det[1][1] = q2.y;
      det[1][2] = q2.z;

      det[2][0] = q3.x;
      det[2][1] = q3.y;
      det[2][2] = q3.z;

      result.w = -determinant(det);
      return result;
   }
EndHLSL

//=============================================================================
// Sin/Cos functions
//=============================================================================
StartHLSL MathSinCos


   //============================================================================================//
   // Compute 4 sincos values in parallel.                                                       //
   // Calculates sin waves assuming input maps each unit (0-1, 1-2, etc) to a single sincos wave //
   //============================================================================================//
   float4x2 SuSinCos4 (float4 aInput)
   {
      float4 vSin;
      float4 vCos;

      //Wrap vSinInput 0-1 and put in range +-Pi
      float4 normalizedInput = (frac(aInput) * 6.28318530) - 3.14159265;

      //Square this in preparation for actual vSinvCos code below
      float4 inputSquared = normalizedInput * normalizedInput;

      //Direct translation from asm code
      vSin = (inputSquared * -0.0000015500992) + 0.00026041668;
      vCos = (inputSquared * -0.000021701389) + 0.0026041667;

      vSin = (vSin * inputSquared) + -0.020833334;
      vCos = (vCos * inputSquared) + -0.12500000;

      vSin = (vSin * inputSquared) + 0.5;
      vCos = (vCos * inputSquared) + 1.0;

      vSin *= normalizedInput;

      vCos *= vSin;
      vSin *= vSin;

      vSin += vSin;
      vCos += vCos;

      vSin = 1.0 - vSin;

      return float4x2 (vSin, vCos);
   }

   //============================================================================================//
   // Compute 4 sin values in parallel.                                                          //
   // Calculates sin waves assuming input maps each unit (0-1, 1-2, etc) to a single sin wave    //
   //============================================================================================//
   float4 SuSin4 (float4 aInput)
   {
      float4 vSin;
      float4 vCos;

      //Wrap vSinInput 0-1 and put in range +-Pi
      float4 normalizedInput = (frac(aInput) * 6.28318530) - 3.14159265;

      //Square this in preparation for actual vSin code below
      float4 inputSquared = normalizedInput * normalizedInput;

      //Direct translation from asm code
      vSin = (inputSquared * -0.0000015500992) + 0.00026041668;

      vSin = (vSin * inputSquared) + -0.020833334;

      vSin = (vSin * inputSquared) + 0.5;
      vSin *= normalizedInput;
      vSin *= vSin;
      vSin += vSin;
      vSin = 1.0 - vSin;
      return vSin;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute hyperbolic sine and cosine values
   ////////////////////////////////////////////////////////////////////////////
   void SuSinHCosH (float x, out float sh, out float ch)
   {
      float ex = exp (x);
      float enx = exp (-x);
      sh = (ex - enx) / 2.0;
      ch = (ex + enx) / 2.0;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute hyperbolic sine and cosine values
   ////////////////////////////////////////////////////////////////////////////
   void SuSinHCosH (float2 x, out float2 sh, out float2 ch)
   {
      float2 ex = exp (x);
      float2 enx = exp (-x);
      sh = (ex - enx) / 2.0;
      ch = (ex + enx) / 2.0;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute hyperbolic sine and cosine values
   ////////////////////////////////////////////////////////////////////////////
   void SuSinHCosH (float3 x, out float3 sh, out float3 ch)
   {
      float3 ex = exp (x);
      float3 enx = exp (-x);
      sh = (ex - enx) / 2.0;
      ch = (ex + enx) / 2.0;
   }

   ////////////////////////////////////////////////////////////////////////////
   // Compute hyperbolic sine and cosine values
   ////////////////////////////////////////////////////////////////////////////
   void SuSinHCosH (float4 x, out float4 sh, out float4 ch)
   {
      float4 ex = exp (x);
      float4 enx = exp (-x);
      sh = (ex - enx) / 2.0;
      ch = (ex + enx) / 2.0;
   }

EndHLSL


